# CPP

* 类成员函数 const.

如果一个函数没有改变自己的内部, 一定要加 const, 因为 const A value; 的时候, value 调用只能调用 const 修饰的函数. 之前没有发现这个事情, 是因为不了解基础知识, 每次都人为的修改函数声明或者变量声明了.

* 带有指针的类, 一定要写拷贝构造函数, 和拷贝赋值操作符

因为, 带有指针的类, 里面会有指针指向的内容, 而这块内容的生命周期, 是这个类应该负责的. 之前拷贝构造考虑过, 拷贝构造的时候, 应该新开辟一块空间, 然后深拷贝原来的值. 但是拷贝赋值的时候, 其实是一样的, 只是指针的 copy, 两个指针指向一个空间. 这是一个很危险的事情. 并且, 如果不释放原来的内容, 会有内存泄漏的.

* 操作符重载, 可以有全局函数, 还有成员函数两种方式, scip 中也说了, 所谓操作符, 其实在计算机眼里, 就是一个函数的调用而已. 在成员函数里面, 只能得到左操作数是当前类的方式. 所以, 对于其他的方式, 就得用全局函数那种方式了. 例如, << 输出操作符, 左边接受的是 cout, 这个重载, 就只能用全局函数的方式了.

* new 的时候会发生什么.
1. alloc, 这里用的 alloc, 这也说明了为什么类的构造函数的时候没有给每个成员变量赋初始值, 这些成员变量会是乱七八糟的值, 而在 oc 的 alloc 中, 会把这块内存做一次清零处理.
1. 将 alloc 返回的 void * static_cast 成为你的类型
1. 用这个指针调用构造函数

* delete 的时候会发生什么
1. 调用对象的析构函数
1. 调用 delete 将这块内存还给操作系统.

* 在 new 之后, 会发生什么事情, 或者 array new 和 new 会有什么区别
1. 真正的内存分配的时候, 除了类所需要的空间大小, 还会有一些其他的空间被分配出来. 在空间的开头和结尾, 会有叫做 cookie 的东西, 里面记录了这个空间总共有多大, 是用16字节为单位的. 上下两个 cookie 的内容相同. 在 debug 模式的时候, 也会有一些 debug 的内容, 同时, 如果总共的空间不是16的倍数, 就会进行填充, 将总共的大小调整成为16的倍数. 在 array new 的时候, 会在整个空间里面, 增加一个 int 的空间, 里面记录了这次 array 里面的数量. 但是, 这个数量并不能说指明这个总共的空间有多少, 空间有多大是在 cookie 里面记录的. 所以, array new 的时候, delete 不会造成这块内容空间不能很好的释放. 它影响的是, delete 只会调用一次对象的析构函数, 而有些空间, 是在对象里面进行内存管理的. 例如, string 里面, 一定管理了一个 c 字符串. 如果array new 生成了三个对象, 用 delete 进行删除的话, 只会调用第一个对象的析构函数, 这样就造成了内存泄漏, 对象管理的那部分空间的泄漏. (以上内存的分配都是在 vc 环境下, 不过语言的处理在不同编译器下应该都一样.)

* 类模板, 函数模板在用的时候最大的区别就是, 类模板要明确的指明里面的类型, 而函数模板则是可以类型推导.

## 类间关系

* composition 生命同步

* delegation => composition by reference 生命不同步 pointer to implementation

这样写的优势在于, 接口可以不变, 而实现类可以随时切换. 这叫做编译防火墙, 可以保证用户那边不用改变. 其实在 tiled 的业务功能里面也用到了这些.
包含类只是对外的接口, 真正的实现在指针指向的实现类

* inheritance 继承, is-a

父类的数据, 是完整的被继承下来的, 包括 private 的
当有类的继承的时候, 父类的析构函数一定要设置成为虚函数, 因为 delete 一个父类指针的时候, 如果不是虚函数, 只会调用子类的析构函数, 这样的话, 子类管理的内存空间就内存泄漏了.

函数的继承, 继承的是调用权.
而 virtual 规定的是重新定义权.