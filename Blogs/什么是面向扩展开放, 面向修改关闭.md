# 面向扩展开放, 面向修改关闭

写代码有一条原则, 开闭原则, 是几条基本的设计原则之一.

```
添加一个新的功能应该是，在已有代码基础上扩展代码(新增模块、类、方法等)，而非修改已有代码(修改模块、类、方法 等)。
```

从对这段时间的面试经历来看, 不少人对于这种理论上的东西, 总是不太重视. 
基础理论, 并不如代码规范那样立竿见影地就能应用到平时的工作中, 但如果从不去思考这方面的知识, 那写出可维护稳定的代码的时机, 也就不断的进行滞后.

## 什么叫修改, 什么叫扩展.

按照最原始的设定, 如果修改了一个类中的代码, 那么这个类就是被修改了. 因为带来的结果是, 这个类要重新进行编译连接, 使用到这个类的其他模块, 功能可能会受到影响.
不过, 添加一个新的功能, 必然要有代码的修改, 就算是有配置文件这种东西, 也是要提前要在代码里面添加对于配置文件的处理逻辑.
所以修改是一定不可避免的, 好的设计的代码, 会将修改点控制在一个可以承受的范围之内, 减少对于其他类的污染.

各种设计模式, 所做的事情都是一样的, "变化点稳定点的分离". 例如, 监听者模式, 主要解决的是数据改变的时候, 如何通知到另一方机制问题, 工厂方法, 解决的是创建过程和使用过程分离的问题. 所以, 分清楚当前代码的稳定点和变化点是非常重要的.

如果代码可以责任分离清晰, 那么就很容易的看出来, 对于某些流程, 无论是数据的传递, 还是函数调用的先后顺序, 都是固定的.
而变化的则是处理过程中, 不同业务想要实现的需求.

以前端时间完成的长文贴解析为例:

```
打算把这段时间自己摸鱼时所看内容分享出来——这核心就是vtuber，也就是虚拟主播。

整体来说这是一个非常神奇的行业，这个行业借助着今年上半年的全球形势，正以一个难以置信的速度增长，然而这个增长却是以一种近乎残酷的方式进行。表象的体现就是当我开开心心地寻找有趣的vtuber看的时候，却同时找到了很多vtuber宣布毕业（就是从此不干了）的直播录像或者视频。国内观众习惯称其为“刀”，这一刀确实捅在心里。一方面是资本不断注入，越来越多人入局的行业，另一方面是已经有人决定放弃。

所以，为了留住曾经有趣的、有价值的瞬间，特开此专栏，把我觉得好的vtuber节目记录一下，并推荐给可能对vtuber感兴趣的读着们。

V活每日推荐 《V事生非 ガチ恋Vtuber篇》（观看链接在文章下方）

今天推荐的节目来自于vtuber因幡はねる。

<McAtTaCH clz="img" w="1493" h="844" url="http://moego-prod-gz-1256467324.file.myqcloud.com/www/admin/web/picture/post/20200627/1593234948200290.png">[图片]</McAtTaCH>

她隶属于vtuber团体“有閑喫茶あにまーれ”，并且是这个团体的leader。首先给因幡はねる几个关键词：睿智、拼命、刚强、阴角。逐一简单

```

用标签的方式, 传递数据, 是一种可以扩展的方式. 理论上来讲, 我们可以将所有的信息, 包括, 现有的图片, 语音, 红包信息, 都用标签的方式, 塞到 content 字段里面. 但是这样做是毫无必要的, 因为这些信息都有着固定展示位置和样式. 所以, content 里面仅仅存放的是图文混排的一些信息. 

对于富文本的处理, 有着一套非常固定的流程: 

1. 解析文本, 提取出符合正则规则的标签文本.
2. 根据标签文本的内容, 将表现的各种信息, 转换成为对应的 UI 视图, 这些 UI 视图带有宽高信息, 用来图文混排.
3. 将非标签文本和生成的视图进行图文混排.

在以上的过程中, 1,3 是非常固定的过程, 1 中会进行正则匹配, 通过匹配出来的标签数据生成对应的数据类,  3 中虽然图文混排是一个技术难点, 但是如果攻克了 "根据 UI 视图的宽高信息嵌入到文本中" 这个问题, 无论之后生成什么样的视图, 3 中的代码逻辑都不会修改.

而 2 中的生成视图的过程, 则是一个变化点, 根据 clz 的不同, 要生成不同的视图类. 生成视图所需要的信息不同, 展示方式不同, 视图的点击回调也不同, 如果将解析过程, 用 switch type 的方式处理, 2 中的代码, 会变为混乱臃肿, 并且随着版本的更新, 只要增加一种新的视图显示, 这块代码就一定要修改. 类中代码越来越多, 改动越来越频繁, bug 也就时不时出现.

这个时候, 可以构建一个抽象接口或者父类 MCAttachParser, 暴露出 "- (NSMutableAttributedString *)attachedContent:(MCAttachModel *)model"  方法, 将各个视图的创建工作交给各个子类去完成. 

通过子类自定义父类行为是最基本的面向对象的设计思路, 不过需要注意的是, MCAttachParser 的抽象, 是属于高层模块的抽象, 它和为了代码复用而建立的父类子类关系非常不同.

上述步骤中, 步骤 2 需要调用一个抽象方法, attachedContent 获取到对应的视图对象, attachedContent 方法的设计, 是由步骤 2 中的代码决定的, 当步骤 2 中的代码, 调用了这样的一个抽象方法后, 它的代码就可以趋于稳定, 当有了新的业务需求的时候, 编程人员只需要创建一个新的类, 然后想办法将这个新类的对象, 传递到步骤 2 中就可以了, 多态的思想, 可以自动的调用各个子类的相关代码, 不用修改步骤 2 中的任何代码. 

步骤 2 的代码不需要改动, 也就意味着主流程的算法稳定, 改动点为设计新的类, 传递该类的对象, 所有的改动封装到一个可控的范围内, 当发生 bug 的时候, 只用去这个可控的范围进行逻辑的梳理, 这是一种有效减少 bug 的手段.

而为了代码复用的父子类关系, 比如 UIButton 的各个子类 Button. UIButton 的抽象含义, 是由这个类设计出来的. Button 的使用者, 要依赖于 Button 的接口定义进行编码, 当 Button 的接口改动时, 使用到 Button 的地方都要进行函数的改名. 

面向扩展开放, 在我看来是这样的一个流程:

1. 找到一套固定的算法, 这个算法可以应对业务场景的需要, 不会轻易发生变化.
2. 在固定的算法的设计上, 将变化点进行提取, 抽象成为一套固定的接口行为, 这套接口是属于这套算法的. 这样这套算法可以保持稳定, 不会轻易随着业务的扩展更改算法.
3. 编写各个场景下的接口实现类, 在使用上述固定算法的时候, 将各个实现类的对象, 传递到算法当中. 根据传递的对象的不同, 算法体现出不同的业务行为.

## 不那么规范的面向扩展开放

实际上, 咱们平时写的代码, 一般不会走到上面的场景中. 在经过几次功能修改之后, 才有必要进行上面的设计, 如果在功能的第一个版本中, 用上述方法写代码, 很可能是徒增复杂度.

不过, 平时我们写代码的时候, 还是可以写出利于维护的代码来. 

```
- (void)setup {
    [self setupVideoContainer];
    [self setupAuditBoard];
    [self setupTitleView];
    [self setupVideoDataView];
    [self setupUserCard];
    [self setupTimeView];
    [self setupBubbleTop];
    [self setupConentView];
    [self setupPromptView];
    [self setupBubbleBottom];
    [self setupTagPanel];
    [self setupAssistView];
    [self setupBottomLine];
}

- (void)updateWithPost:(MCPostModel *)postModel {
    _model = postModel;
    [self updateTitleView];
    [self updateAuditView];
    [self updateUserCardView];
    [self updateTimeLabel];
    [self updateContentView];
    [self updatePromptView];
    [self updateAssistView];
    [self updateTagPanel];
}
```

上述是帖子详情视图的相关代码.
帖子详情, 作为一个视图控件, 基本没有抽象的可能性.
那么在新增了展示逻辑的时候, 如何将变化点控制到最小呢.
通过上面清晰的命名, 可以人工制造出一个稳定的算法来. 

setup 相关的方法, 将各个不同的展示视图创建, 封装到各个子方法的内部.
update 相关的方法, 将各个不同的展示视图更新逻辑, 封装到了各个子方法的内部.
setup, update 是一套非常固定的算法, 阅读者可以很清晰的知道类的实现方式, 可以很快速的寻找出 bug 产生的代码的范围.

当有一个新的业务场景的时候, 比如, 帖子详情中可以展示某个电影明星卡片时, 所需要的做的就是, 在 setup 方法里面, 增加 setupStarView 的调用, 在 update 方法里面, 增加 updateStarView 的调用.
setupStarView, updateStarView 是新的业务逻辑, 被封装到了自己的方法内部. setupStarView, updateStarView 的调用, 插入到 setup, update 逻辑中. 
在帖子详情增加电影明星卡片的改动中, 改动点控制在 "两个新方法的定义, 以及两个新方法的调用中". 类的其他部分保持了稳定, 这样也可以认为是面向扩展的设计.

写出利于扩展的代码的关键就是, 找出代码中稳定点和变化点, 尽量将变化点控制在可控的范围内, 减少对于其他代码的破坏.
在记忆的时候, 只去记忆这些固定的算法, 这样, 就能够记住更多的实现的细节.
