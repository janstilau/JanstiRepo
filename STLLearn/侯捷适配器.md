# 适配器

adapter, 它的作用, 其实是换肤功能, 并不改变原有的实现.

* 容器适配器

  stack, 和 queue 对于 deque 的改造. deque 里面的功能太强大, 不符合 stack 和 queue 的定义, 重新包装 deque, 减少暴露的功能. 并且, deuqe 里面的函数命名, 不符合 stack 和 queue 的函数命名, 重新命名函数, 让使用者方便使用. 底层实现, 还是 deque.

* 仿函数适配器
* 迭代器适配器

他们的作用, 都是改造原有的实现表现, 但不是改变实现. 所谓的改造就是, A 作为 B 的桥梁, A 面对使用者, 但是 A 其实是将工作交给 B 做, 这其实, 就是设计模式的适配器模式. 适配器, 都是用 composition 的方式使用的.

## function Adapter --> 把东西记起来, 以备后来使用

之前 iOS 的下载图片的策略是什么. ImageView 的回调里面, 是拿到 iamge 对象之后, 做一些 imageView 的赋值操作, iamge 的回调是, 拿到 NSData, 然后做一些图片相关的工作, 而 NSData 的回调, 是拿到数据之后, 做数据的缓存操作. 所以, 其实是, NSData 的回调里面, 包含了 image 的回调, image 的回调里面, 包含了 imageView 的回调. 那么 NSDATA 的回调呢, 包含在下载操作完成之后. 也就是说, 一个函数的具体实现, 是做自己的一部分操作, 然后调用自己保存的函数.

这是闭包的特性, 可以保存自己捕获到的任何东西.

之前我一直在写, functor, 可以看做是 oc 中 block 的实际的对象模拟. 其实 function Adatapter, 不就是闭包包含闭包的方式. 都是存储函数的实际调用地址和数据, 然后在未来中进行调用. 如果没有调用, 存储的值只是存起来, 根本就没有被调用过.

block 要我们明确的写出, 函数的调用, 才能完成实现的细节.
function Adatapter, 则是一个框架, 可以让我们用传入传出的方式, 完成功能的组合. 这也符合类的设计, 类是一个框架, 模板, 真正起作用的是类生产出来的对象. 这种组合的方式, 也是需要对象. 但是, 下面的binder2nd<???> 中间应该怎么写呢, 很难写出来, 所以标准库写出来一个帮助函数, 来实现binder2nd的对象生成.

在函数的实现里面, 有很多 Operation::second_argument_type 这样的调用, 其实就是在询问, 如果我们没有继承 unary_function 之类的东西, 编译的时候就会出错.


``` cpp
template <class Operation>
class binder2nd: public unary_function<typename Operation::first_argument_type, typename Operation::result_type>
{
public:
    binder2nd(const Operation* x, const typename Operation::second_argument_type &y):
            op(x),
            value(y)
    {
    }

    typename Operation::result_type operator() (const typename Operation::first_argument_type &x) const
    {
        return op(x, value);
    }

protected:
    Operation op;
    typename Operation::second_argument_type value;
};

template <class Operation, class T>
inline binder2nd<Operation> bind2nd(const Operation &op, const T& x)
{
    typedef  typename Operation::second_argument_type arg2_type;
    return binder2nd<Operation>(op, arg2_type(x));
};

```
