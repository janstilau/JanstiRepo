# 排序

## 概念

在分析排序之前, 要明确几个概念. 这里, 只是简单说明一下自己的理解. 

* 时间复杂度

一个算法的执行时间, 随着数据量的增长, 会体现出不同的增长曲线. 这和数学上的方程式是一样的. y = 5x + 1,
在坐标系中, 是一条斜线, 而 y = x<sup>2</sup> + 2, 在坐标系中, 是一条越来越陡峭的曲线. 把 y 认为是总的执行时间, x 作为是数据量的大小, 可以知道, 高阶算法, 在数据量达到一定程度的时候, 总的执行时间会变得过长. 在分析时间复杂度的时候, 一般可以省略常量, 系数, 只关注最能影响增长趋势的数值.

时间复杂度用 O 表示. 主要有 O(n), O(n<sup>2</sup>), O(2<sup>n</sup>), O(log n), O(N*logn), O(n!)

* 空间复杂度

一个算法, 除了输入参数所占的空间外, 在算法内部要定义多少空间来执行. 在排序算法里, 如果需要的额外空间是一个常量, 不和数据规模相关, 可以称这个算法为原地排序算法. 如果需要申请和数据规模相关的另外一个空间, 例如要申请同样大小的空间, 则不能称之为原地算法. 注意, 这里额外申请空间要和数据规模有关, 就算是申请 100MB的空间, 也算作常量时间. 因为数据规模可能远远超过 100MB.

* 稳定性

两个相等的值, 如果排序之后, 前后顺序没有发生改变, 那么这个排序算法可以称之为稳定排序算法. 稳定性有什么用呢, 稳定的算法, 就可以用在多关键字的排序中. 例如, 学生按照成绩排序, 相同成绩的按照班级排序. 如果先用班级排序, 然后用稳定算法按照成绩排序的话, 按照成绩排序的时候, 之前按照班级排序的前后顺序还是可以保持的. 这样的代码要比寻找相同成绩的区间然后在区间内按照班级排序的代码简单的多.

* 比较, 移动次数

排序需要大量的比较, 移动位置的操作, 如果一个相同时间, 空间复杂度的算法, 这两个步骤的次数少, 那么要比同类的算法要好.

* 有序度, 逆序度

 1, 2, 7, 3, 5, 9. 在这串数据里面, [1 2] 是有序的, 而 [7, 5] 是无序的. 数据里面, 任意两个数值都可以组成一个有序对 或者 无序对. 两者的个数就是有序度, 无序度. 排序的过程, 就是消灭无序对的过程.

## 主要算法

所有算法都是按照从小到大进行排序.

### 冒泡排序

* 冒泡排序的主要思路就是, 相邻位置比较, 例如0,1两个位置比较, 将较大的值放到1的位置 然后1,2继续比较, 将较大的值放到2的位置. 这样到最后, 最大的值一定在最后一个位置. 然后重新从0,1开始比较, 将次大的值放到倒数第二个位置

* 冒泡排序的时间复杂度是O(n<sup>2</sup>), 在冒泡排序代码中, 如果发现一次遍历没有交换, 代表所有数据都在有序的位置, 可以提前退出.

* 冒泡排序是原地排序, 在比较交换的过程中, 如果相等情况不交换, 那么就是稳定的算法.

* 冒泡排序每一次交换, 消灭一个逆序对, 正是因为如此, 它不是一个优秀的排序算法. 交换的过程, 需要用到三条语句, 这也导致基本主流的排序不会用到这种算法.

### 插入排序

* 插入排序的主要思路是: `1, 7, 2, 3, 5, 9` 这组数据, 开始认为1是一个有序的数组, 取出7来插入到这个有序数组中, 得到 `1, 7` 这个有序数组, 然后2插入到这个有序数组中, 得到 `1, 2, 7`有序数组. 以此类推. 这个过程, 利用的就是数组的插入操作.

* 插入排序的时间复杂度也是O(n<sup>2</sup>)

* 插入排序是原地排序, 在插入的过程中, 如果数值相等的话, 将带插入元素放到后面位置, 那这个算法那就是稳定算法.

* 插入排序, 一次插入的时候, 后面位置的数值每移动一次, 就是消灭一个逆序对. 插入排序比较次数少, 后移操作要比交换操作步骤少的多, 所以执行效率要比冒泡排序好得多.

### 选择排序

* 选择排序的主要思路是:遍历整个数据, 找出最大的数值的位置, 然后将最后一个位置和该位置进行交换. 然后遍历整个数组, 找到次大值的位置, 然后和倒数第二个位置交换.

* 选择排序的时间复杂度也是O(n<sup>2</sup>), 选择排序交换动作, 一次能消除很多逆序对, 但是找出最大值需要遍历整个数组, 所以大量的比较操作导致时间复杂度增高.

* 选择排序是原地排序, 但不是稳定算法. 6, 3, 5, 8, 3. 这数据在排序之后, 后面的一个3会到第一个位置. 时间复杂度高又不是稳定算法, 导致选择排序用的几率很少. 

### 归并排序

* 归并排序的主要思路是, `1, 9, 3, 5, 10, 23, 2, 5.`这组数据, 从中间平分, 然后左边部分排序, 右边部分排序, 然后将两个部分数据合并到另外一个数组中, 在合并过程中, 按照从小到大的顺序放置数值. 因为左右两个子数组是有序的, 所以这个合并的过程代码很简单. 而两个字数组怎么排序呢, 还是递归调用归并排序, 将左子树组分为两个数组, 排序之后合并. 在被分的子数组大小为1的时候, 开始进行递归的回溯.

* 归并排序的代码相对复杂一些, 又要用到递归, 所以不好理解. 不过, 它的时间复杂度为O(nlogn), 其实可以这样理解, 归并排序每次都会从头到尾遍历一次数组, 第一次只保证最小的子数组内部有序, 下一次遍历的时候, 合并操作可以将小的子数组组合成为更大一点的数组有序, 下一次遍历又是一次合并有序操作. 这就像是 222222, 444, 84, 12. 这样的一个过程, 每一次都将子数组的个数减少一半. 这符合 log 这种函数出现的特征.

* 归并排序最大的问题就是, 不是原地排序算法, 需要一个进行合并的数组. 不过归并排序是稳定算法.

* 规定排序在合并的过程中, 一次的位置改变, 可以消除很多逆序对. 这也是为什么规定排序快的原因之一. 好的排序算法, 一定会让自身的一次位置移动, 消除尽可能多的逆序对.

### 快速排序

* 快排的主要思路是: `1, 9, 3, 5, 10, 23, 2, 5.`这组数据中, 选择一个值作为 pivot, 然后从两头向中间遍历数组, 从头遍历的发现比 pivot 大的停止, 从尾遍历的发现比 pivot 小的停止, 然后交换这个两个值, 直到遍历的指针相遇. 然后将 pivot 移动到相遇的位置. 这样, pivot 所在的位置就是最终排序好后的位置, 而左边都是比自己小的, 右边都是比自己大的. 然后左边, 右边子数组递归用这种方法进行排序.

* 快排的时间复杂度是 O(nlogn), 快排的交换操作, 可以一次消灭许多逆序对. 这也是它快的原因 

* 快排是一个原地算法, 但不是一个稳定的排序算法. 快排是一个大量使用的算法, 原地算法最好的时间复杂度也就是 O(nlogn). 原地算法这一点很重要, 归并排序使用的少就是因为它需要另外的一组空间, 这在排序大规模数据的时候, 是一个致命缺点.

### 堆排序

在堆数据结构中在介绍

### 桶排序

* 桶排序的主要思路是: 首先建立一个有序的桶, 这个桶可以是内存空间, 也可以是文件空间. 然后, 遍历整个数组, 按照数值的范围, 将不同的数值放到桶里面. 然后对于桶内的数据进行排序, 用到上面提供的各种排序算法. 在各个桶排序完成之后, 因为桶本身是有序的, 所以按照桶的顺序, 可以算出最终的排序好的数据.

* 桶排序的时间复杂度可以达到 O(n).

* 桶排序不是原地排序算法. 应该说, 桶排序之所以快, 就是因为它利用了大量的空间. 根据桶的分割, 将要排序的数组, 分割为各个小数组. 小数组将排序的数据规模进行了大幅度的削减, 这是它快的主要原因.

* 桶排序大量的应用在外部文件排序的过程中, 因为这种排序的数据类太大, 计算机内存一般难以承担. 这还是利用了空间进行的排序.
