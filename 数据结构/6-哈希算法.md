# 哈希算法

## 概念

散列, 哈希都只是 hash 这个单词的音译, 不过, 现在哈希算法, 一般指代了几个固定常用的算法. 这几个算法的作用是将任意长度的二进制值串映射为固 定长度的二进制值串，而通过原始数据映射之后得到的二进制值串 就是哈希值. 在这里, 哈希值不再是非负整数, 而是一个固定长度的二进制值串. 这其实是和哈希算法的应用场景有关. 哈希算法得到的值, 不在作为数组的索引使用, 而是作为原有数据的代替, 或者缩略图使用.

## 算法特点

* 从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法)
* 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同
* 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
* 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值

现在常用的哈希算法有, MD5, SHA1, SHA2 等, 它们都遵守上面规则, 只不过生成的串的长度和生成算法不同. MD5 生成的串的长度为 128bit, 所以它的值的范围可以达到 0 -- 2^128-1, 这虽然是一个天文数字, 但是实际的数据是无限的, 所以会出现不同的数据的 MD5 值相同的情况, 不过, 可以在平时的开发场景中, 可以认为 hash 值和原有数据是一一对应的.

## 算法应用

1. 加密

从哈希值不能反向推导出原始数据 可以使得哈希算法作为加密的手段. 哈希算法的原本作用, 并不是加密, 而是提供一种算法可以计算出可以代表原有数据的缩短的二进制串. 不过由于这个算法是不可以从 hash 值推导出原有数据的, 所以在原始数据经过 hash 之后, 被人截获也没有了危险. 这里有个问题, 既然已经经过了加密, 那么接收方也无法进行解密的. 在平时的密码存储的时候, 服务器端也是不知道用户的密码到底是什么的, 服务器端直接存储的就是用户密码的哈希值. 真正的密码只掌握在用户的手中, 用户在输入密码之后, 进过哈希处理传到服务器端, 服务器端用之前存储的哈希值和传递过来的值进行比对, 如果一样, 则认为是输入了正确的密码

1. 唯一标识

之前说过, 哈希冲突是一定存在的. 但是由于哈希算法得到的值的范围很大, 可以近似的认为哈希值可以代表原始数据. 在一般的业务中, 也是通过哈希值代表数据的. 假设有这样一个场景, 存档文件需要每5分钟进行一次自动备份, 这个备份放在另外的一个目录下好让用户在误操作之后可以恢复, 这个应该怎么做呢. 比较笨的办法是, 每5分钟, 将存档文件现有的数据和之前的数据逐字节进行比较. 这样虽然可以实现功能, 但是耗费时间过大. 比较好的办法是, 存储原有数据的 hash 值, 然后和现有数据的 hash 值做比较. hash 值是一个很短的字节值, 比较的时候要快很多. 这里, 就是认为 hash 值可以代表原始数据, hash 值成为了存档文件的唯一标示.

1. 数据校验

数据校验使用的还是 hash 值可以算作数据的唯一标示的特性. 这个主要在网络传递的过程中. 简单来说, 传输的时候不但传输原有信息, 还会传递原有信息的 hash 值信息. 当接收端接收到原有信息后, 对原有信息取 hash 值, 然后和传递过来的 hash 值做比对. 如果两个值不一样, 就可以认为原有信息不完整, 或者被人篡改了.

1. 散列函数

散列函数的主要作用是什么, 是进行数据的分组, 每个数据通过散列函数之后, 可以计算出应该存放到数组的哪个位置. 哈希算法本身的设计就符合散列函数的某些特点, 例如分布均匀, 计算快速, 只不过得到的值是一个二进制串. 而这个二进制串, 可以通过某些简单的换算, 变为一个非负整数. 比例, 这个二进制串可以转换为字符串, 然后用过字符串的 ascii 值, 生成一个非负整数. 所以, 在需要进行数据分组的场景下, 先将数据进行哈希处理然后进行分组是一个非常普遍的行为.

## 总结

哈希算法的应用非常广, 作用也很好理解, 不需要了解算法的实现细节. 它的作用是将原有数据转换成为一个固定的串值, 由于这个串值一般要比原有数据小很多, 用这个串值代表原有数据会提高各个操作的性能. 它常常用在数据安全, 缓存, 校验的业务场景下.