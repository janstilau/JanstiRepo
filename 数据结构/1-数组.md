# 数组

## 概念

(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据.

线性表表示有序的一个列表. 在线性表中, 除了第一个元素, 都有前一个节点, 除了最后一个元素, 都有后一个节点. 除了数组, 还有链表, 队列, 栈等数据结构, 它们都有着有序的概念.

数组最重要的特征, 是连续的内存空间, 以及数组中元素是相同的类型. 这里的类型更多表示的是, 占据相同的内存空间, 例如数组元素类型都是 整型, 浮点型, 或者指针, 都是占据固定的内存长度. 指针可以看做是一种特殊的类型, 指向不同类型的对象, 利用数组中存储指针, 可以达到数组里面存放不同类型的对象. 但是在数组看来, 存储的类型是指针这种类型, 还是拥有固定的内存大小.

## 随机访问

数组相同类型的这种限制, 帮助数组获得了特殊的能力, 因为编译器是可以直接将类型翻译为长度的. 数组的[]中括号操作符可以变换成为内存地址计算式. 例如, `dataSource[3] === dataSource + sizeOf(itemType) * 3`, 在这其中, dataSource 数组名会被编译器转换成为数组的起始地址, 起始地址加上偏移量可以直接得到想要操作位置的内存地址, 在得到内存地址后, 直接操作相应对应地址的数据. 这种通过简单的计算就能找到相应位置的优势, 被称之为随机访问. 随机访问十分重要, 经过简单的计算, 直接可以取得对应位置的数据, 使得数组中存储的数据, 在进行大量的读写操作时, 耗费很少的性能.

## 低效的插入删除

随机访问有两个前提, 一是相同类型的数据, 二就是数组中的数据必须紧紧相连, 中间不能出现空的情况. 否则, 上述的计算式就不起作用了. 为了达到数据紧紧相连的限制, 数组在插入数据, 删除数据的时候, 要做大量的工作维持自己元素在内存中紧紧相连的特性.

在插入数据的时候, 如果待插入的数据, 在数组的末尾, 直接将数据添加到数组末尾就可以了. 但是, 如果插入的位置在其他的位置, 为了维持数组的特性, 首先, 要把后面所有的数据, 做一次整体的向后搬移, 然后将被插入的数据赋值到插入位置. 内存的迁移是一件昂贵的事情, 尤其是在数组达到一定规模之后.

在删除数据的时候, 情况刚好相反, 在数组末尾删除数据, 直接将数据删除就可以了. 但是, 在其他位置删除数据, 会造成数组内部出现空值. 这个时候, 就需要将后面的数据整体向前搬移. 同样的, 这也是一件昂贵的事情.

数组的插入删除, 之所以要做这么多工作, 是因为要保持数组的随机访问的特性. 所以, 在使用数据的时候, 如果读数据的操作, 远远小于写入数据的操作, 就应该考虑选用其他的数据结构.

数组的插入删除如此昂贵, 也会有相应的优化的办法. 在插入数据的时候, 如果数组中有序的概念不重要, 那么可以将待插入的位置数据, 直接搬移到数组末尾, 然后将插入的数据放置到待插入的位置 这样做, 数据迁移的工作, 只进行两次, 一是将原来数据放置到末尾, 二是将数据放置到相应的位置. 在同时删除多个数据的时候, 可以将被删除的位置, 设置一个特殊的标志位, 表示为空, 待全部删除之后, 在将数组做一次整理操作, 将空位置剔除. 这样做, 可以将多次的内存搬移, 减少为一次.

## 长度和容量

数组中, 长度指的是, 数组中已插入元素的长度. 而容量, 则是一个C语言时代相关的概念, 数组是一块连续的内存空间, 而这块内存空间, 是需要提前向操作系统申请的. `int data[20]`, 这个语句, 是向操作系统申请 20 个 int 这样大小的空间, 在申请之后, data 里面的长度是0, 容量是20, 代表这个数组可以插入20个 int 数据. 在添加了20个 int 值之后, 这个时候, 数组的长度和容量是相等的, 数组已满不能添加元素, 此时添加元素, 其实是逻辑错误. 同样的, 访问数组中不存在的元素, 也是逻辑错误的, 例如, 数组中只有4个元素, 却用 `data[10]` 这样的语句访问, 得到的结果必然是不在数组中的数据, 这种情况又叫做访问越界.

## 数组类

各个类库都有数组对应的类, Vector, NSArray, Array 等都是对于数组的封装. 原始的数据操作过于复杂, 要由程序员管理内存, 程序员记录长度信息, 容量信息. 所以, 如果直接使用数组的话, 非常容易出现访问越界的情况, 在各个语言中, 都有自己的数组类, 管理真正底层的存储数组, 并提供了相应的实现逻辑.  

在用数组类进行数据访问的时候, 如果发生了访问越界的情况, 一般会抛出异常, 使得程序崩溃. 这其实是数组类内部的安全机制, 因为如果发生了访问越界, 还继续运转程序, 就会导致数组外不受编码人员控制的数据被任意的修改.

数组类在高维层面, 对数组进行了封装, 并提供了良好的接口, 并维护数组的概念. 在进行插入, 删除操作的时候, 数组类内部, 会对底层的数组进行数据搬移的工作, 并且会维护长度值. 数组类完全接管了对于内存的管理操作. 在原始的数组中, 容量限制了数组的长度, 而在数组类中, 可以无限插入数据, 仿佛没有尽头. 这其实是因为, 数组类中, 在数组的容量不够的情况下, 会申请开辟一个新的内存空间, 这个新的内存空间的大小, 一般是原来空间大小乘以某个系数得到的, 然后将原来的数据进行一次复制操作, 在这以后, 才会将带插入的数据插入到新的内存空间的相应位置. 开辟内存空间, 数据迁移是一个昂贵的过程, 但是数组类的封装, 让使用人员完全意识不到其中数据迁移的操作. 不过, 如果知道了这一点, 那么在预先知道要插入数据长度的情况下, 最好使用带有容量信息的构造函数, 这样可以减少很多次分配内存, 数据迁移的工作.

基本上, 我们编码会直接使用数组类, 而不再使用最原始的数组, 但是数组类仅仅是对原始数组的封装, 数组的随机访问和插入删除的低效, 都还实际存在于数组类的内部. 所以, 应该在使用的时候, 注意多进行随机访问操作, 少插入删除.
