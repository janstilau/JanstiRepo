# TS

TS里面的类型, 是一种轻量级为函数和变量添加约束的方式, 只要两个类型的结构和类型匹配, 那么这两个类型就是兼容的. 这就保证了我们实现接口的时候, 只要保证结构和类型匹配就可以, 不用明确的 implements 声明.

在类的构造函数上面能使用 public, private, protected, readonpy, 等同于创建了同名的成员变量. 这是 TS 提供的快速开发的语法糖, 不过明确的写出成员变量来要好一些.

## 接口

TS 的核心在于, 对于值所具有的数据结构进行类型检查. 接口的作用就是为 命名, 结构, 类型做一个约束. 但是是用一种包容式的检查, 它不需要像其他语言那样, 要求你明确的定义接口, 然后明确的要某个类实现这个接口才能调用, 而是在编译的时候发现可以符合就会通过. 因为, TS 经常使用匿名对象和字面值初始化, 所以这种符合通过的方式更加适合动态语言. 只要对象满足于接口描述的条件, 那么这个对象就是被接受的.

## readonly

变量 const, 属性 readonly

## 函数类型

接口可以表示函数, 它的方式, 就和 block 的声明一样. 首先, 我们应该清楚, JS 中的所有函数都是闭包, 也就是说, 函数的名字, 仅仅是一个变量名, 在 JS 里面, 没有其他语言那样的函数签名, 可以说, JS 里面只有函数指针的概念, 函数名只不过是存有函数指针的对象的变量名.
那么对于这种语言的函数, 函数的类型, 也就是 参数个数, 参数类型, 和返回值类型了. 所以, 表示函数的接口, 也就是这些. 和 OC 里面的闭包是一样的.

## 索引类型

索引类型, 其实就是函数类型, 不过是 单个变量的函数类型, 用[] 这种方式特殊的进行表示.
需要注意的是, 只有 number 和 string 两种索引类型, 并且 number 返回的类型必须是 string 返回类型的子类型. 原因是, number 的索引, 最终也是变换成为字符串形式. 因为对象的属性, 除了 symbol 都是用字符串表示的.
字符串索引还会影响到属性的返回值类型, 所以设置字符串索引必须要谨慎.
可以在前面增加 readonly.

## 类

类可以实现接口.
接口可以互相继承, 如果有冲突的话, Ts 会报错

## 接口继承了类

类的继承的话, 会继承基类的实现. 类本身也是一种接口, 所以接口也能继承类, 不过, 接口仅仅是继承类的接口部分, 不会继承实现部分. 这是理所当然的, 所以, 对于类里面属性这一部分, 在接口继承类之后, 实现接口的类, 要重新定义真正的数据实现.

## 继承

TS 里面的类的概念, 和 JS 中几乎相同. 但是增加了访问权限的设置, 就是 public, protected, private. 这三个关键字, 和 C++ 中是一样的. 不过, 是需要在每个属性前面增加, 默认是 public.

TS 是结构性类型系统, 只要两个类型的所有成员是兼容的, 那么这两个类型的对象就是兼容的. 但是 private, protected 的时候, 另外一个类型拥有同样的结构, 并且他们必须来自同一声明, 才是兼容的. 也就是说, 这两个对象的私有, 保护变量必须继承自同一基类, 如果私有, 保护变量仅仅是名称和类型相同, 还是不会认为是兼容的.

## 静态属性

和 JS 里面定义一样, 这些静态属性, 是定义在类上面, 也就是构造方法上面的.

## 抽象类

抽象类和 C++ 里面是一样的, 不过抽象类的类定义的时候, 也要在类前面加上 abstract. 也即是类和方法定义前面都要加上 abstract.

## 高级技巧

* typeof 这个关键字很重要, 因为 TS 里面有着类型声明一说, 所以得到变量以后, 用 typeof 拿到它的类型, 放到变量后面做类型声明, 是一个很常见的事情.

* 类也是一个接口, 类中除了构造函数 和 static 的属性, 其他的都是描述一个对象的属性. 这和一个接口的作用是一样的.

* 函数的类型, 就是 参数类型, 参数顺序, 还有返回值类型. 函数名称不重要, 函数名称不重要.

* TS 里面, 函数的参数的个数, 必须和接口的一样. JS 里面函数的参数是可传可不传的. TS 里面, 必须是明确的写出是可选的, 或者设置了默认参数值, 这个值才能被省略. 多余接口的函数调用, 还是会被认为是错误的. 默认参数值得函数原型, 和可选函数原型是一样的. 也就是默认参数值, 是在可选的基础上, 添加的默认值.

* TS 里面也可以用... 当做剩余参数使用, 他会被当做是一个数组, 所以在他后面, 要按照数组的方式添加类型.

* 如果, 我们想让捕获的 this 有类型, 那么需要在函数的形参里面增加 this 变量, 并且明确的指出 this 的类型. 如果 this 的类型是 void, 那就是表示, 这个函数不能使用 this.

```TS
interface UIElement {
  addClickListener(onclick: (this: void, e: Event) => void) : void
}
```

这里, this 的理解还是有问题.

* 重载

应该说, TS, JS 中都没有重载, 这里的重载, 仅仅是添加了更多地函数声明. 然后, 写一个通用的处理参数返回值都是 any 的函数, 在这个函数里面, 写出 typeof 这样一个能够通用处理的函数出来. 这个函数, 不会被当做是重载的定义, 也就是说, TS 在处理类型匹配的时候, 不会调用真正的拥有定义的函数声明. 注意, 函数的声明可以有很多份, 但是函数的定义只能有一份.

## 泛型

泛型的定义和其他语言的泛型, 没有任何的区别. TS 里面有 any, 可以面对任何类型. 不过, any 会丢失类型信息, 这个时候, 泛型可以保持类型信息.

泛型函数, 还是不用明确的指出函数的类型参数是什么, 通过参数的类型, 编辑器可以做出推导.

不过, T 上面是不能够使用方法或者读取属性的, 因为 TS 会做类型的限制. 注意, 这里其实和 C++ 的模板有着挺大的区别. 在 C++ 里面, 方法的调用可以随便写, 属性也是可以随便写, 因为 C++  实际上会根据传入的类型参数生成相对应的函数和类, 如果这个过程中发现问题, 在编译的时候就会报错.

但是 TS 里面, 泛型实际上, 是在 JS 没有类型基础上做出来的. 它实际上是为了 TS 的类型信息系统服务的. 所以, T 没有 extends 接口的时候, 实际上我们拿到一个 T, 任何方法不能调用. 只有在 T 里面明确的说了, extends 某个接口, 才能调用这个接口里面的信息.

C++ 里面的泛型, 没有这样做, 所以, 它只能用泛型类型名做一个暗示, 告诉使用泛型的人员, 去传入一个符合名字暗示的类型名过来, 而 Ts 中, 通过 extends 接口的方式, 明确的限制了, 泛型, 也会有约束.

```TS
function identity<T>(arg: T): T {
  return arg;
}
```
泛型类的概念, 和之前 C++ 的是一样的, 在使用的时候, 必须明确的写出类型的信息.

## 枚举

数字枚举. 和之前的语言一样.

字符串枚举. 所有的字符串枚举都要进行初始化.

## 类型兼容

TS 里面的类型兼容, 和名义类型声明有很大的不同. 名义类型声明是指, 通过明确的声明和类型名称, 类型之间的关系, 来进行类型的校对. 例如, 实现了某个接口, 参数明确是哪个类型, 类型之间的继承关系等等. 而 TS 里面, 是基于结构子类型, 只要结构匹配的上, 结构上面的类型匹配的上, 那么类型就可以兼容.

之所以这样的设计, 是因为 TS 里面广泛的使用匿名对象和对象字面量, 这些是没有办法明确的通过声明的方式来标明自己支持某些约束的. 所以, 结构子类型更符合 TS.

* 函数兼容

