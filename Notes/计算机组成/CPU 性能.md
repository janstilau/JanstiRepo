# 冯诺依曼体系

* CPU, 内存, 主板, IO 设备各自的作用和功能
* 南桥用来控制 IO 设备的, 一般来说, 通信的速度没有那么快. 北桥是用来 CPU, 内存通信的, 现在基本消失了, 功能内嵌到了 CPU 中. 南桥北桥都是芯片组, 芯片组控制着数据的传输的方向, 总线是数据传输的载体.
* 冯诺依曼, 存储程序计算机. 可编程计算机是指, 计算值执行的程序是可以改变的. 不可编程的计算机, 就是计算器, 内部逻辑结构是固定的电路板确定的, 可编程的计算机, 例如学习组成原理的时候各个按钮不同的打开关闭, 代表不同的指令, 是可以收起修改的. 可存储的计算机, 指的是程序可以存储到计算机内存中, 可以通过加载来进行执行的. 各种按钮式, 插线式的计算机, 程序不能进行存储, 不能够下次复用. 所以可编程可存储的计算机, 会成为主流.
* 任何计算机的任何的一个部件, 都可以归到 运算器(运行当前指令), 控制器(控制下条指令), 存储器(存储程序, 也就是指令序列和各种数据), IO 设备, 现代的计算机, 都是在这个基础架构中设计开发的.
* 所有的计算机程序, 可以抽象为, 输入设备读取数据, 通过运算器和控制器来运行存储在内存中的程序, 然后把结果输出到输出设备中.
* 计算机组成的学习, 就是学习上面各种部件, 是如何工作, 如何配合的.

# 性能

* CPU 主频, 代表着 CPU 一秒钟可以执行多少个时钟周期, 可以近似的理解为, 一个时钟周期, 可以执行一条简单指令. 想要提升性能, 可以让 CPU 跑的更快, 也就是 CPU 的主频变得更高.
* CPU 的吞吐量, 指的是 CPU 在单位时间内能够处理多少指令. 一个 CPU 内核, 一个单位时间, 只能处理一条指令. 这个物理的限制. 想要提高吞吐量, 靠的是增加 CPU 内核的数量.
* CPU 的每条指令, 所需要的时钟周期是不一样的. CPU 的切换, 是按照指令为界限的, 这也就是为什么高级语言要简单的语句, 也要进行加锁的原因.
* CPU 性能, 也就是一秒钟可以做的事情, 可以是 主频 * 吞吐量 , 主频代表 CPU 有多快, 吞吐量代表 CPU 一次可以执行多少指令. 
* CPU 的主频, 是依靠着晶体管的个数以及晶体管的切换频率控制的, 现在以及到达极限了, 这是物理世界对于 CPU 的限制. 而 CPU 的主频, 是依靠 CPU 内部的一个叫做晶体振荡器来控制的, 所谓的超频, 就是让这个控件变快, 那么 CPU 的频率也就变快. 当然, 超频意味着 CPU 寿命的缩短.
* CPU 的吞吐量, 是依靠多核 CPU 进行提高的. 一个 CPU 内核, 还是只能在一个时钟周期内处理 1 条指令, 但是多核就可以处理多个指令. 不过, 可以多核处理的任务, 是那种可以并行处理的任务. 如果并行处理完成之后的结果, 需要串行进行合并计算, 那么串行的时间, 改用多少还就是多少. 这也就是, 代码里面并发执行任务, 但是最终结果如果要串行合并, 那么串行合并的这一部分的时间, 是不会因为并发而减少的原因. 
* 现在 CPU 的主频, 最高不过 3.2 HZ, 不过内核数量, 已经可以到达 8, 16, 32 了.
* 对于程序员来说, 一段代码的性能, 是指的这段代码最终编译连接后变成的指令的数目的多少. 程序员作为软件开发工程师, 不能控制用户的硬件设备. 也就是, CPU 的主频, 以及核心数量, 都是客观存在的. 只能通过, 减少代码的运行次数来提高性能.
* 还有一点就是, 充分的利用多核 CPU, 将原来串行的任务, 按照条件改为并发执行. 例如, 萌股的图片上传的功能, 多张图片, 是可以同时长传的. 而多张图片上传之后的后续处理, 是必须串行执行的. 所以, 上传代码改为多线程实现, 可以大大的减少发帖功能的实现时间.

## 计算机指令

* 从硬件上看, CPU 是超大规模集成电路, 从软件上看, CPU 是可以执行计算机指令的逻辑机器. 不同的 CPU 可以执行的指令不一样, 也就是说, Intel 和 ARM 的 cpu 的指令, 是各自厂商自己编写的. 编译汇编所做的事情, 就是将高级语言的各个操作, 变成不同 cpu 下可以执行的不同指令.
* 所谓代码段, 里面存的就是各个指令的编号. 编译做的是, 将高级语言的代码, 变成汇编语言. 而汇编做的是, 将汇编语言变成指令数据. 汇编语言是可以移植的, 只有指令数据是各个 CPU 各自独有的.
* 算术类指令(ADD), 数据传输类指令(Load word, 从内存的固定地址加载数据到寄存器中), 逻辑类指令(Or, And), 条件分支指令(判断两个寄存器的值是否相等, 把结果存储到特定的寄存器), 跳转指令(跳转到指的的地址, 然后执行这个位置的指令). 指令里面, 不仅仅存储指令的序号, 也有可能存储操作数的值和操作寄存器的地址. 所以, 最原始的纸带, 不过是把指令通过纸带这种方式进行了表示.
* 高级语言, -> 编译器 -> 汇编代码 -> 汇编器 -> 指令 -> 连接器 -> 可执行文件 -> 加载器 -> 内存中的数据 -> CPU运行内存中的数据 -> 程序开始执行.


## CPU内部寄存器

* PC 寄存器, Program Counter, 指令地址寄存器, 用来存放下一条需要执行的指令的内存地址.
* 指令寄存器, 用来存放当前执行的指令
* 条件码寄存器, 用来存放条件判断的状态, 指令可以根据这个状态值, 进行条件判断. 
* 各个用来存放数据和内存地址的寄存器.
* 一个程序的指令, 是一条条连续保存在内存中的, PC 也会一条条的加载. 对于条件判断这种指令, 会修改条件码寄存器里面的值, 如果条件码里面的值为特定值, 会执行 JMP 指令, JMP 指令会修改 PC 里面的值. 这样, 下一条指令就不是顺序加载出来的了. 这也就是 if, else, while, for 这些语句能够控制流程的原因.
*  这一讲的核心在于理解几个寄存器的作用，从而理解cpu运行程序的过程：cpu从PC寄存器中取地址，找到地址对应的内存位子，取出其中指令送入指令寄存器执行，然后指令自增，重复操作。所以只要程序在内存中是连续存储的，就会顺序执行这也是冯诺依曼体系的理念吧。而实际上跳转指令就是当前指令修改了当前PC寄存器中所保存的下一条指令的地址，从而实现了跳转

## 函数调用

* CALL 指令, 后面跟着程序地址, 这就是函数调用.
* 函数的汇编代码中, 开头会有 push, mov 指令, 结束的时候, 会有 pop, ret 指令. 这就是函数的入栈出栈的操作.
* 函数调用的跳转, 在对应的函数指令执行完之后, 还要回到函数调用的地方, 继续执行函数调用之后的指令. 这个返回之后的地址, 就是栈帧的一部分, 程序就是根据函数调用栈, 保存函数调用关系. 在每次调用函数的时候, 调用函数的返回地址, 还会有那些传递的参数信息, 会变成一个栈帧, 存到栈中. ret 这个指令, 就是返回记录的指令地址.
* 程序内联可以减少栈的大小. 内联的代价是, 不会进行指令的复用, 程序展开比较多, 程序所占的空间也就变大了.

## 静态链接

* 真正的可执行文件, 除了各种指令外, 还有其他的数据. 例如, 符号表, 符号表可以当做是一个的字典, 将名字和地址进行映射. 链接器, 会扫描所有的目标文件, 将所有的符号表中的数据收集起来, 构建一个全局的符号表. 除了符号表外, 还会有一个重定位表. 重定位表中的数据, 是在目标文件中, 还未确定的地址. 例如, main 中调用 add 函数, 而 add 函数的定义在 add.c 中, 那么 main 的目标文件中, add 函数就在重定位表中. 连接器会把所有的目标文件, 汇集到一个文件中, 在这个文件中, 目标文件中的代码段, 数据段, 各自的符号表, 重定位表会进行融合, 使得各个符号(无论是函数还是全局, 静态数据)的地址固定, 然后存储到符号表中, 然后会根据重定位表, 将各个不能确认的符号, 根据符号表中的地址映射, 修正为真正的地址. 这样, 可执行文件中, 所有的跳转地址, 就正确了.
* 不同的操作系统下, 这个可执行文件的格式是不一样的. 虽然代码段的各个 cpu 指令是相同的, 但是可执行文件的符号表, 代码段起始位置的寻找, 都不相同. 加载器是要根据固定的文件格式去加载可执行文件, 将程序变为进程的. 都是 Intel 同一块的 CPU, Linux 和 Win 下得到相同程序的可执行文件是不同的, 这就是不同的操作系统, 要各自进行编译连接的原因.

## 内存的调度

* 虚拟内存, 就是指令在可执行文件中的内存. 它是连续的, CPU 运行的时候, 从起始的地址开始运行, 顺序执行指令, 如果有跳转, 也按照虚拟内存中的地址进行跳转. 但是, 实际的物理内存不能够保证加载到内存中的数据是连续的, 也不能保证是所有的程序指令都加载到了内存中.
* 分页机制. 操作系统, 按照 4K 为单位, 进行内存的划分. 加载程序到内存的时候, 也是按页进行加载的. 哪一块指令, 加载到了哪一块实际的物理内存中, 这都被操作系统记录了下来. 当一个程序执行的时候, 跳转到还没有加载到内存中的指令的时候, 会发生缺页异常. 操作系统会把对应代码所在的虚拟内存代码段, 按页加载到物理内存中, 然后通知程序继续执行异常前的跳转操作. 操作系统这样的设计, 使得内存中, 同时运转多个程序变得可能. 也将程序员, 和具体的物理内存的地址映射, 分离开, 专注于程序代码的编写, 而不用管具体物理硬件的配置.

## 动态链接
* 如果一个代码库, 被多个程序使用, 那么每一个程序都进行静态链接, 那么相当于内存里面这个代码库的代码, 都要占据内存的空间. 如果只占用一份, 然后其他的程序可以动态的链接到这一份代码库中, 就可以节省大量的空间了. 这就是动态链接的意义. Win 下, 动态链接库为 DLL 文件 Dynamic Link, Linux 下是 so 文件, ShareObject.
* 动态链接库必须是地址无关的代码, 这个可以在编译的时候指定. 也就是说, 在 IDE 中, 选择代码编译成动态链接库, 那么编译出来的代码就是地址无关的. 大部分的函数库, 都是可以做到地址无关的. 他们结构特定的输入, 进行操作, 然后返回结果就可以了. 而业务代码的, 通过连接器和符号表进行修正的代码, 都是地址相关的, 每个函数的位置, 都在可执行文件中, 固定了下来. 而动态链接库中的变量和函数调用, 使用的都是相对地址, 也就是说, 各个指令使用到的内存地址, 是一个相对于当前指针偏移量的地址, 因为整个动态库都是放在一段连续的虚拟内存地址中的, 所以相对地址是不会变的.
* 虽然动态链接库中的代码部分在物理内存内存中是共享的, 但是数据部分, 在各个链接到的应用程序中, 是各自加载一份的. 而这些数据部分中, 有一个叫做 GOT , 全局偏移表的东西. 在这个表中, 记录着当前共享库在当前的应用程序的地址偏移量. 知道了这个偏移量, 然后知道了共享库中各个变量和函数, 和这个偏移量的相对地址, 共享链接库的地址也就确认了. GOT 表中的数据, 是在程序运行时, 加载共享库的时候不断地进行修改的, 而不是编译时进行确定的.

## 编码格式

* 整数. 对于无符号的整数来说, 所有位上面的数字, 都可以当做数据位进行考虑, 而对于有符号的整数来说, 最好位则是符号位. 所以, 相同位数, 无符号可以表示的正数是有符号可表示正数的两倍, 因为一半表现为了负数.
* 补码到底是什么东西. 1001, 这个数字代表的是 -7, 它怎么来的呢. 其实是 -1 * 2的三次方, + 1 * 2的零次方, 所以是 -1. 最高位为 1, 比如是负数, 因为后面的几位的最大值也不会超过最高位代表的负数值. 所以, 得到的值, 是后面的值和最高位的一个差值. 补码最大的好处, 就是 -1 + 1 的时候, 可以直接进行二进制的加减, 最后一位进位变成了 1010, 这还是补码进行表示, 就是 -6. 而如果是 -7+7, 就是 1001 + 0111, 变为了 0, 这也是二进制相加得到的结果.
* 字符集指的是, 收录一部分字符, 然后为每一个字符指定编号. 现在都是在用的 UNICODE 字符集. 而 UTF8, UTF16, UTF32 都是对于 Unicode 字符集的不同的编码格式而已. 具体的编码格式规则没有详细的理解, 简单来说, UTF8 可以根据编码的前几位, 判断下一个字符占用了多少字节进行的存储. 例如, 英文字符, 都是可以用一个字节进行存储的. 这样, 就可以减少某些常用字符的存储空间, 否则, 都按照 UNICODE 最大字符编号那么多的存储空间进行存储, 例如要占用 4 个字节, 那么 a, b, c 这些简单的字符, 本可以用一个字节进行存储的数据, 要扩大 4 倍才可以, 过于浪费.
