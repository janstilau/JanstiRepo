# 正则

## 定义

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。

## 基础字符含义

### configure

* 忽略大小
* 处理多行, 如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处.

### quantifier

* \*, 它指定*重复任意次(可能是0次)
* +, 重复1次或更多次
* ?, 重复零次或者一次
* {2}, 前面内容必须连续重复匹配2次
* {5,12}, 重复的次数不能少于5次，不能多于12次.

### content

* \b, 匹配单词的开始或结束
* \s, 任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等
* \w, 匹配字母或数字或下划线或汉字
正则表达式里的单词, 就是不少于一个的连续的\w. 和各个人文语言的单词没有太大的关系.
* ., 匹配除换行符以外的任意字符
.*连在一起就意味着任意数量的不包含换行的字符
* \d, 匹配一位数字(0，或1，或2，或……)
* 不是元字符的字符, 只匹配它本身.
* ^, 匹配字符串的开始
* $, 匹配字符串的结束

### transferred meaning

查找元字符本身, 需要明确的标识出, 想要查询的是元字符, 这样解析器就不会用特殊的含义解释这些. 当然, 通用的自然是 \ 这个字符. 这个编程语言里面, 用 \ 进行转义是相同的. \., \*, \\, 这里不用太多解释.

### combination

你想匹配没有预定义元字符的字符集合, 就用方括号将他们列出啦. [aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)

## 分支条件

正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开  

``` C++

0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。`

\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

```

## group

用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作. 相当于, 这个组被当做是一个独立的单元进行处理.

```C

正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。

```

## 反义

\W 匹配任意不是字母，数字，下划线，汉字的字符
\S 匹配任意不是空白符的字符
\D 匹配任意非数字的字符
\B 匹配不是单词开头或结束的位置
[^x] 匹配除了x以外的任意字符
[^aeiou] 匹配除了aeiou这几个字母以外的任意字符

## 后向引用, 零宽断言

这些平时没有用到, 没有读

## 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）

```C++

*?    重复任意次，但尽可能少重复
+?	    重复1次或更多次，但尽可能少重复
??	    重复0次或1次，但尽可能少重复
{n,m}?	    重复n到m次，但尽可能少重复
{n,}?	    重复n次以上，但尽可能少重复

```

## 处理选项

IgnoreCase(忽略大小写)	匹配时不区分大小写。
Multiline(多行模式)	更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
Singleline(单行模式)	更改.的含义，使它与每一个字符匹配（包括换行符\n）。

多行, 单行仅仅是没有任何关系. 他们的作用都是改变某个字符的含义而已.