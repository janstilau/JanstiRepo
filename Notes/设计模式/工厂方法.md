# 对象创建模式

避免对象创建的 new 的过程, 因为 new XXX(X, Y, Z) 这样有着强耦合(依赖了具体的类), 从而支持对象创建的稳定.

设计模式, 并不能消灭变化, 而是将变化集中在一个地方, 在这个点可以对变化进行控制.

## 工厂方法

提供一种封装机制, 来避免 new 具体的类型.

定义一个用于创建对象的接口, 让子类决定实例化哪一个类, 工厂方法, 让一个类的实例化延迟, (目的: 解耦, 手段: 虚函数) 到子类.

首先, 应该考虑会不会有变化, 如果没有变化, new 一个实际的类型, 然后调用这个类型的功能, 这当然没有问题. 但是如果有变化呢.

什么是变化, 就是运行的时候, 或者之后的代码中, 这个具体的实现可能会修改. 那好, 为了应对这种变化, 会有一个基类, 然后具体的子类实现具体的实现. 这样更改实现的时候, new 不同的子类对象, 就改变了这个调用的具体实现. 这样就是面向接口编程, 典型表现就是, 变量是抽象基类类型.

但是这样还有什么问题?
变量是抽象基类的, 但是 new 的过程, 还是要写明了具体子类的. 这样, 高层模块, 还是需要知道底层模块存在才能编译完成.
例如 Abstract *mSpeaker = new ChineseSpeaker(); ChineseSpeaker 只要出现了, 就是依赖这个类存在, 才能完成编译.

那么如何解决这个问题?
对于创建对象这个工作, 如何让它在运行时可以进行更改呢. 根据多态的实现, 如果有一个基类, 它有不同的子类, 通过子类的指针, 我们可以调用基类的方法, 只要指针变化, 他们的行为就会变化.

工厂方法就是在这, 工厂方法的基类, 只是有一个创建对象的接口, 不同的工厂, 创建不同的对象, 然后真正需要对象的地方, 拿到的是工厂的指针, 通过调用工厂的方法, 得到对象, 只要传入的工厂不同, 得到的对象也就不同.

这样的话, 改变的地方在传入工厂的代码里面, 只要得到了工厂, 生成对象的代码, 使用对象的代码, 都是拿到的对象的基类接口进行操作的, 那些地方, 统统都不需要更改.

之前还对, 一个对象一个工厂这种设计感觉很蠢, 其实上, 工厂这一个级别, 主要是为了创建对象这个函数可以多态化的一个中间层.

## 要点

工厂方法模式, 用于隔离类对象的使用者和具体类型之间的紧耦合, 使用 new, 紧耦合, 会导致软件脆弱化.
工厂方法, 是通过面向对象的方法, 将具体的对象创建工作, 延迟到工厂的子类, 这是一种可以扩展的策略.
工厂方法, 主要解决单个对象的创建变化.

## 简单工厂方法

简单工厂方法, 也是有个 factor 类, 然后通过传入 enum, int 值,  返回一个对象. 一般来说, 简单工厂方法就是一个大的 switch 的分化处理逻辑.

工厂方法里面, 生成什么对象是工厂决定的, 简单工厂方法, 是传入的参数决定的, 也就是调用者决定的.

简单工厂方法, 也能解决依赖的问题, 简单工厂封装了对象的创建过程, 使用对象的代码, 并不知道对象的创建过程和实际的对象类型, 还是对接口编程.

简单工厂方法, 具体哪一个类型的对象生成, 是根据 int 值决定的. 而这个 int 值是怎么来的, 是调用工厂方法的单元决定的, 还是外界传进来一个数字, 然后调用工厂方法的单元仅仅是传递的作用呢. 从 UIEditor 来看, 调用工厂方法的是 doc 对象, 但是 doc 对象有一个 createElement(int) 的方法, 这个方法里面有个形参 int, 然后这个形参直接传到了简单工厂方法里. 所以说, 变化的来源还是在外界, 无论是按钮的点击, 还是读取文件得到的类型值. 所以, 变化还是在具体的业务层面上.