# 组合优于继承

策略模式里面, 在主体类的功能完成之前或者之后, 策略类要执行一些额外的工作. 应该怎么设计.
如果用继承的方式, 相当于是原有主体类的代码, 对于子类是公开的, 子类通过 父类::函数调用的方式调用 父类的代码, 用来执行原来的功能. 这样的方式, 是在编码的阶段, 将代码组合在了一起, 算作功能组合的静态绑定. 静态绑定的问题在于, 不灵活, 如果想要多个装饰类功能一起作用, 或者更为严格要求多个装饰类功能有着先后顺序, 那么就要现编写那么多类, 在类的代码里明确的写出来代码的调用顺序和层级关系模型.

这里面其实有着大量的冗余代码, 例如, 一个装饰类的功能, 在每个复杂的类里面, 都要重写一遍, 一丁点变化都没有. 这么多的冗余一定是有问题的. 并且每个类都是相似的, 每个函数都是, 调用自己代码, 调用父类代码, 调用自己代码. 这里面, 变化的部分就是自己的代码那部分, 相同的部分是调用父类代码的部分. 如果能修改调用父类代码那一部分, 那么整个架构都会变化.

策略模式, 在每个装饰类里面, 有一个基类的指针. 然后将原有的 父类::函数调用的部分完全变成了 基类指针->函数调用. 这样有什么好处?

组合, 就意味着是可以动态变化. 我之前一直在说一句话, 就是我们能够改变的只有内存里面的值. 改变内存里面的值之后, 就改变了虚函数表的指向, 然后就可以更改功能的实现.
仔细想一想, 上面 基类指针->函数调用 和父类::函数调用, 功能是完全相同的. 代价是, 原来构建子类, 自动的完全了父类的构建过程, 现在构建装饰类, 需要首先拿到被修饰类, 然后将被修饰类赋值到修饰类的内部. 运行时组合好不好要分时间讨论. 为什么会有模板方法设计模式. 模板方法设计模式, 将函数的调用写在一个统一的函数里面, 给出来修改的权利仅仅是一些子步骤, 因为模板的运行时稳定的, 子功能是变化的. 这就是静态绑定的优势, 首先稳定的部分, 交给别人进行组装, 对于别人的负担太大, 再者, 稳定的部分, 交给别人组装, 就可能让程序功能不稳定, 如果使用人员根本就不了解运行机制, 就根本写不出正常的调用代码.

对于策略模式所解决的这个问题, 它本身就不是一个稳定的结构, 主体类是稳定的, 所以主题类里面, 没有基类指针, 它只能作为被修饰的成分, 但是修饰类之间的组合, 以及组合的顺序完全是动态变化的, 对于这种动态变化的部分, 我们用组合的方式, 来实现, 也是用到了组合所带来的可以变化的特点.