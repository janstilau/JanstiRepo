# 单一职责模式

如果责任划分的不清晰, 使用继承得到的结果就是, 随着需求的变化, 子类快速膨胀, 同时, 充斥着重复的代码, 这个时候的关键在于, 划清责任.

## 装饰者模式

动态(组合) 地给一个对象, 增加一些额外的职责, 就增加功能而言, 这个模式比生成子类(继承)更加的灵活, 消除了重复的代码, 减少了子类个数. 是组合优于继承的非常好的体现.

### 动机

过度的使用继承, 来扩展对象的功能, 由于继承为类型引入了静态特质(调用时固定的, 是代码里面写明的, 动态就是, 调用时通过指针调用, 在多态的基础上进行的, 动态特质)), 使得这样的扩展方式没有灵活性, 并且随着子类的增多, 各种子类的组合, 会使得子类膨胀.

例子: 
Stream 基类
FileStream 子类
MemoryStream 子类
NetrowkStream 子类
CryptoFileStream 子类. 增加了加密功能
CryptoMemoryStream 子类
CryptoNetrowkStream 子类
AuthFileStream 子类 增加了验证功能.
AuthMemoryStream 子类
AuthNetrowkStream 子类
AuthCryptoFileStream 子类, 增加了加密验证功能.
BufferAuthCryptoFileStream 验证, 加密, 缓冲 文件 流.

以上, 是编译的时候, 将功能装配起来了.

问题就是, 随着功能的增加, 子类是功能 * 功能 * 功能 这样的方式进行扩展的. 类爆炸
第二个问题就是, AUTH 的代码, 在所有 Auth 的子类里面, 代码都是一样的, 存在着大量大量的冗余代码.

## 要点

基类定义了接口, 主体类是具体的实现, 而装饰类是为了给主体类增加功能. 主体类中, 是直接继承, 里面没有用到组合, 而装饰类, 则是继承加组合, 继承为了规范接口, 组合为了调用所修饰类的功能.

用组合方式, 来实现多态的支持. 实现了在运行时候, 动态的扩展对象功能的能力. 并且, 可以根据需要扩展多个功能.

decorator 类在接口上表现为 is-a 的继承关系, 但是在实现上, 又是 has-a 的组合关系. 继承, 是为了接口的一致性, 装饰类的操作, 和应该和基类一样, has-a 是为了实现, 在完成装饰的代码之后, 应该调用所装饰类的代码, 来实现更上层的代码的调用.

装饰者, 并不是为了解决 多子类衍生的问题, 而是解决, 主体类在多个方向上扩展功能.


