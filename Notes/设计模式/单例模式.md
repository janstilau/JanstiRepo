# 对象性能模式

## 单例模式

保证整个系统中, 只存在一个实例, 才能保证他们逻辑上的正确性, 以及良好的效率.

类的设计者, 应该确保只有一个实例, 而不是让使用者犯错. 应该做的就是, 不给使用者创造第二个对象的能力.

## 实现

写一个构造函数然后私有, 如果不写, 默认生成的, 其实是公有的.

static 作为单一的对象.

其实这个主要是线程那边有问题. 实际上专门处理线程很少用. 因为实际上, 几乎不会出现多线程同时调用生成单例的情况.

加锁, 如果一进来就锁, 每次 get 都加锁, 代价太大. 读操作是不需要加锁的. 只有读写一起的时候, 才会产生问题.
如果真的是高并发的环境, 每次读都加锁, 会让高并发变成单线程. 而读操作一般都不需要加锁的.

如果 if 之内加锁, 其实可能会出现创建两次的问题
重构后变成为, if 之内加锁, 然后加锁之后再判断一次.

双检查锁在 reorder 的时候, 会出现问题. 不过, 真正有影响的时候在研究吧.
