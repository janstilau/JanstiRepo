# 桥模式

如果责任划分不清, 通过继承得到功能类, 结果往往是随着需求的变化, 子类急剧膨胀, 同时充斥着重复的代码, 这个时候, 关键在于划分责任.

策略模式 --> 将装饰类的代码, 划分到真正的特定的装饰类, 而不是用继承的方式, 每个都要写一遍.

桥模式 --> 将抽象部分, 和实现部分进行分离, 以便让他们可以独立变化.

## 动机

某个类, 有着多个变化的维度.

## 例子

Messager
// 功能实现
// 平台相关实现
Message 有两个变化维度, 平台相关的代码, 需要子类去实现, 而功能相关的代码, 也需要子类实现, 现在下面有 PC, 和 Mobile 另个平台, 然后每个平台下有各自的功能实现. 现在, 如果增加一个平台, 那么需要的子类是3个, 也就是子类的个数, 其实是变化维度做乘法.
而且, 里面充斥了大量的重复代码. 不同的平台, 他们的功能实现代码是完全相同的, 不同的仅仅是平台相关的那些函数. 但是, 为了能够让代码跑起来, 功能实现相关的代码, 在每个类中都要写一遍.

PCMessager
// 实现平台相关
PCMessagerLite
// 功能实现
PCMessagerPerfect
// 功能实现

MobileMessager
MobileMessagerLite
MobileMessagerPerfect

## 桥模式解决方案

上面的设计, 将平台实现, 和 message 的功能实现放在了一起, 这样就让 messager 类有着两个变化的维度, 其实是因为责任划分不清. messager 的责任应该是 message 的功能实现, 平台相关的功能应该是另外一个类的事情. 当两个独立的功能, 各自都要变化的时候, 为了应对变化, 只能是生成相乘个数的子类, 来应对需求的变化.

这和策略模式很像, 策略模式变化的维度是, 每一个装饰类, 都是一个新的维度, 这样其实不能固定下来成员变量的个数, 所以策略模式有点递归调用的味道, 调用自己代码之后, 再调用 指针->相同功能的代码.

但是桥模式不一样, 还是上面的 messager, messager 的功能代码里面, 其实是会调用平台相关功能代码, 所以, 应该是messager 里面, 有着一个平台相关实现类的指针. 然后在构造不同的 messager 实现类的时候, 传入不同的平台相关实现类的指针. 这样, 还是利用组合的方式, 将各自有着明确功能的两个类进行组合, 而组合的方式, 是在运行时期动态组合的, 这种动态组合, 可以将需要用代码预先定义的类的个数从 相乘关系, 变到相加关系.

核心观点还是, 职责分离, 组合代替继承.

不变的地方: 功能实现需要调用平台实现的固定方法.
变化的地方: 功能实现, 平台实现 各自代码都会变化.
桥模式, 将不变的地方, 用指针调用的方式固定下来.