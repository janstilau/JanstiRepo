# 原型模式

Prototype 的意义在于，你拿到一个 Base* ，它指向某个 Derived 对象，你想克隆出 Derived 对象，但代码中不写出 Derived 的具体类型，因为有很多派生类，这种情况下你用构造函数是搞不定的，type-switch 是 bad smells 。另外，这里考虑 virtual 的性能损失是主次不分，构造对象需要分配内存，这开销比一次虚函数调用大多了。Prorobuf Message 就采用了 prototype 模式，你可以参考一下。

李建忠的设计模式里面,  提出了另外一个想法, 为什么不用工厂方法呢?
我们拿到一个原型对象, 想要拿到这个原型对象的拷贝去做某些事情. 但是当前这个原型的当前状态是复杂的, 并不是构造出来的初始状态, 这个时候, 用原型模式通过原型获取一个新的对象, 是最简单的办法.

原型模式, 可以认为是 实际的 product, 以及生成这个 product 的工厂的结合.

那么这样的话, 对于使用对象的类, 如果使用的是工厂方法, 那么就是它的构造函数里面, 传入的就是一个工厂的实例,  如果用的是原型模式, 那么传入的就是一个原型的实例对象. 只不过获取对象的方式一个是通过工厂, 一个是通过原型克隆.

原型模式实际上用的不太多. 就如同, OC 里面, copy 很少使用. 
OC 里面, 实现深拷贝, 一般可以通过 NSCoding 进行序列化和反序列化.
