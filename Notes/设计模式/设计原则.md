# 设计原则

面向对象的设计, 主要用于, 抵御变化.

## 面向对象重新认识

* 隔离变化 
    类的封装, 各不同功能模块的封装. 类之间的相互协作, 是通过接口的方式.
* 各司其职
  各个类都有自己单一的责任, 更改一个类的内部实现, 不应该会对别的类有影响
  多态, 接口一样, 但是实现不一样, 各个子类有着自己的实现, 对自己负责

对象是什么?
语言层面, 封装了代码和数据; 可以被复用的公共代码; 拥有某种责任的抽象. 类, 就是一种类型, 而类型, 应该是接口的集合.

## 例子

MainForm 作为画图程序, 里面有 Line, 有 Rect.

## 原则高于一切, 高于具体的模式, 不要把设计模式当算法来学习, 然后在应用的时候生搬硬套, 一定要保持设计模式数上面的代码结构. 很多模式已经被语言内部机制解决了

各个设计模式, 都有着相同的点, 那就是稳定点和变化点. 设计模式的作用就是, 将稳定的部分和变化的部分进行隔离, 变化的部分像接口进行靠拢, 而稳定的部分则通过接口进行调用. 接口应该是稳定的. 这样, 稳定的部分可以保持稳定, 而变化的部分, 可以在接口之下进行变化.

## 依赖倒置原则 非常重要的原则

高层模块(稳定)不应该依赖于低层模块(变化), 二者应该依赖于抽象.
抽象(稳定)不应该依赖于实现细节(变化), 实现细节应该依赖于抽象(稳定).

高层 MainFrom
低层 Line, Rect

如果一个稳定的类依赖于变化的类, 那么稳定的也就不稳定了, 变化的类更改代码之后, 稳定的模块也要改变相应的调用的代码.
而如果两者都依赖于抽象, 稳定的模块仅仅是调用抽象的接口, 变化的部分随便变化, 但是保持实现抽象的接口, 那么稳定的部分一直可以保持不变.
不应该依赖细节 --> 抽象的父类, 应该保持不变, 而作为实现的子类, 自己变化, 父类的接口一直要保持不变.
不应该依赖细节 --> 不要在一个功能的代码里, 将功能实现之后引起的变化也写到里面, 变化是多种多样的, 如果增加一种变化, 那就要修改这个功能的代码. 这个功能完成后, 应该寻找某种方式将自己完成的状态通知到后续变化单元, 具体有什么单元, 是可以动态变化的. (观察者模式)

这样的设计, 子类可能实现变化, 可能不断增加, 但是父类, 还有依赖父类调用的其他高层模块可以一直保持不变. 这样就隔离了变化.

## 开放封闭原则

对于扩展开放, 对于更改封闭.
类的模块, 应该可以扩展, 但是不可以修改. 就是增加新的功能, 用增加类的个数的方式增加, 而不是修改原有类的实现.

为什么改变的代价非常高. 只要改变, 改变的文件, 就要重新编译链接发布. 所以有的时候, 改变一个头文件, 所有用到这个头文件的文件都要重新编译. 当需求变更的时候, 增加一个类, 来处理新的需求. 利用多态来改变对象的实际行为, 将扩展写在新的子类里面. 这样可以减少已有代码的修改, 更重要的是, 这样更加的安全.

## 单一职责原则

一个类, 应该只有一个引起它变化的原因.
这个在桥模式里面有着很好地体现. 桥模式的例子里面, 一个 messager 类里面有自己的功能实现代码, 也有平台实现的代码. 这样, 功能 和 平台, 两个维度同时变化的化, 就是相乘个数个子类, 如果分为两个类, 然后在功能类里面调用平台类的功能, 那么每个类各自变化, 子类的个数就能够大大的减少.

简单的来说, 不要把那些不知道写在哪的代码, 统统放到一个类里面, 一个类, 应该有自己具体的功能, 不要做代码的万花筒

## 替换原则

子类, 必须是 is a 基类, 子类必须能够表达成基类
那么, 所有需要基类的地方, 子类指针都能传过去.
如果, 子类不能实现父类的所有方法, 或者, 父类的有些方法子类不应该实现, 那么这个子类就不是这个父类
这个原则其实很多时候需要考虑下自己的代码功能实现, 例如经常举得两个例子, rect 和 square, 企鹅和鸟, 如果它们为父子类, 对于现在的代码其实没有影响的话, 其实就可以成为父子类, 如果确实是对现在的代码造成了伤害, 就应该考虑下中间生成一个中间的类. 不要死板的动用原则.

## 接口隔离

不应该强迫客户依赖他们不用的方法
接口应该小, 并且完备.
public 的接口, 应该是非常非常珍贵的. 一旦别人用上了你的接口, 你就没法改了.
public 中暴露的东西, 应该是一个 class 的 type 的具体体现, class 是一个用户自定义类型, 这个自定义类型到底是干什么的, 就应该从 public 暴露出来的接口来体现.

## 优先对象组合, 而不是继承

类继承, 是白盒复用, 对象组合, 则是黑盒.
继承, 破坏了封装性, 子类父类耦合, 父类不能轻易修改.
对象组合, 仅仅要求被组合的对象有良好的接口, 耦合度低.
对象组合, 可以模拟继承的效果. 对于 super.operation(), 可以用 pointer->operation() 的形式代替. 不过需要在代码里面明确的写出来, 而继承则是自动可以调用父类的功能实现.
组合可以应对变化, 缺点在于, pointer 到底指向什么需要外界决定, 这样才能实现动态变化的效果.

## 封装变化点

分界层, 让设计者可以在一层修改, 而另外一层保持稳定.
其实类的实现就是这样, 接口保持不变, 类的底层数据, 私有函数可以随便变化.
应用的不同子系统其实也是这样的, 一个子系统, 暴露出来的仅仅是外界可以调用的部分, 而自己的细节实现, 实际上是它们自己进行管理的, 并且, 随着迭代, 子系统的底层实现是随时可以变化的.

这一点, 在 OC 里面是比较好. OC 可以在实现文件里面可以定义私有方法, 这些私有方法不用在 OC 的 h 文件里面声明一次, 而 C++ 作为一个老语言, 所有的方法都要在头文件中声明, 虽然是 private 的作用域, 但还是修改了 h 文件, 会引起重新编译.

## 针对接口编程, 而不是实现

客户不需要知道具体的类型, 只需要知道调用的接口. 所有的模块, 都是针对接口编程. 这样, 高层可以保持稳定, 底层可以随意变化. 扩展可以添加类来实现, 高层也不用修改. 这和依赖导致原则相辅相成.

## 接口, 一定要标准化

核心, 就是分工协作, 通过接口来进行中间的联合, 通信协议, http, tcp, 各个工业产品的可以高度的流水化, 都是生成的部件要符合某些标准, 都可以当做是接口. 接口标准对于提高工作效率有着非凡意义.

## 重构

应对变化, 提供复用. 是好的设计模式

现在软件的特征是需求变化频繁, 所以, 首先应该是寻找变化点, 然后在变化点上使用设计模式, 从而去应对需求的变化. 什么时候, 什么地点应用设计模式,是在重构的过程中发现的. 代码中, 有一些是稳定的, 有一些是变化的, 23种设计模式, 解决的都是变化和稳定之间的关系, 对于稳定的部分, 用基类和对于基类的调用固定下来, 对于变化的部分, 用子类进行实现. 所有的设计模式, 都是为了应对变化的部分, 所以找到稳定的部门是非常重要的. 如果稳定变化之间的分歧点没有找到, 一定要套用设计模式, 那么结果往往是最后推翻重来.

一上来就用设计模式, 是对设计模式的最大勿用. 没有一步到位的设计模式, 敏捷软件开发提倡的就是 重构, 一步步到稳定的设计模式. 首先, 完成功能, 然后发现现有代码的问题, 通过修正, 得到能够运转良好并且易于扩展的解决方案, 才是对项目更加适合的设计模式.

## 重构的关键

代码中写死  ->  通过接口调用
静态绑定 -> 动态绑定
早绑定 -> 晚绑定
继承 -> 组合
编译时依赖 -> 运行时依赖
紧耦合 -> 松耦合