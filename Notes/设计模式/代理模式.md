# 代理模式 Proxy

为已有的对象, 提供一层代理, 用来控制对于这个对象的访问.

这个模式, 实现很简单. 不变的部分, 是对于原有对象的调用, 变化的部分, 是原有对象调用前, 对于这个调用的控制. 这种控制, 是根据业务功能, 在代理类里面编写的.

增加一层间接层, 是软件系统中, 对于复杂问题的一种常见的解决方法. 在面型对象的系统里面, 如果直接使用某些对象会有很多问题, 那么增加作为中间层的 proxy 对象, 就是解决这一问题的常用手段.

## 适配器模式

将一个类的接口, 转化成为现在所需要的接口.

用的也是很多. 比如 tiledUrl 就是对于原来的 Qurl 的适配.

书中给的例子, 都是原有的对象放在新的环境中, 但是其实, 在侯捷的 STL 中也讲过, 适配器可以是一种封装的概念. queue 是 deque 的适配器, 其实是封装了 deque 到自己的内部, 然后隐藏了大部分 deque 的接口, 只是留出自己所需要的那些, 作为自己的方法.

## 中介者模式 Mediator

MVC 中的 C.

各个对象之间, 不需要显示的互相引用, 而对他们之间的状态变化, 在中介对象里面进行封装.

这个模式其实很乱, 只是将一团互相引用的线, 变成了集中到一点控制, 但是这个点, 会变得越来越复杂. 好处就是好追踪, 所有的逻辑都可以在这个点里面进行梳理, 但是随着业务越来越复杂, 里面的代码会越来越乱.