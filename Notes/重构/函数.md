# 函数的重构

## 提炼函数

短小命名良好的函数

* 如果函数的粒度小, 那么函数复用的机会也就越大
* 高层函数的调用会像是一系列注释, 所以, 必须要求有良好的命名.
* 函数都是颗粒度, 那么复写也会变得容易.

命名的时候, 以函数做了什么命名, 而不是函数怎么做.

真正的抽取工作, 其实工作中应用的很多. 主要是, 应该这样做, 而不是怎么做.

## 内联函数

```cpp
int getRating() {
  return (moreThanFive()) ? 2 : 1;
}

bool moreThanFive() {
  return (_numberOfStudent > 5);
}
```

如果, 某些函数的内部实现, 和名称一样的清楚, 那么就应该去掉这个函数, 然后直接使用里面的代码. 间接性可能会增加帮助, 但是硬加上去的中间层让人不舒服.

如果当前的函数组合不是很合理, 将所有的调用内联到一起, 然后在重新抽取, 这样比较容易重构.

## 用查询代替临时变量

程序用一个临时变量, 保存某一个表达式的运算结果, 将这个表达式抽取到一个独立函数之后, 所有对于这个临时变量的引用都换成这个函数. 这样, 之后的函数也能利用这个函数了.

可能会担心性能问题, 所以这个先暂缓执行.

## 一个临时变量, 不要多次赋值

如果是累加的临时变量, 或者迭代变量, 那自然是可以多次赋值. 但是如果一个变量被多次赋值了, 那么很有可能是变量的责任不清晰. 之前写代码, 经常为了重用变量, 将同种, 之后无用的变量重新填入一个值, 这样后面填入的值, 很有可能已经失去了第一次赋值的时候的含义. 这个时候, 重新定义一个变量也不是多内存消耗的事情.

## 引入一个解释性的变量

经常在判断式里面, 有着很复杂的表达式操作, 这个时候, 将这个复杂的表达式赋值到一个有着良好命名的变量里面, 之后通过这个操作, 由于这个变量有着良好的命名, 阅读的时候也就能清楚的之后现在的逻辑.

在复杂的算法里面, 良好的命名可以作为算法逻辑的标志.

作者经常使用提取函数的办法, 因为, 函数其实也有着自解释的名称. 但是我觉得一个类里面有着太多的函数, 哪怕是 private 的函数都是不太好的, 如果一个表达式, 仅仅是在一个函数里面被调用了, 那么用变量来进行表达其实就是很好了, 这样所有的功能都在一个函数里面, 不会污染类的空间, 这样读这个类的人, 不用去关心那么多的私有函数是不是真的很重要. 如果, 这个表达式在多个函数里面都有涉及, 这个时候在提取出一个小函数也为时不晚.

在这里, 函数里面的变量用 const 体现是一个很平常的事情, 之前的代码, 很少用 const ,其实是不应该. 在 swift 里面, 专门对 const 有一个 let 定义, 也是鼓励用 const 明确的展示变量的意义, 按照临时变量不要多次赋值的说法, 大部分的变量都应该是 const 的.

## 不要对参数赋值, 除非它是一个输出参数

这个在 swift 里面已经上升到了语言的层次了.

由于参数都是值传递的, 对于参数的任何行为其实都和调用者没有任何关系的. 如果传过来的是一个对象指针或者引用, 在它上面调用方法, 确实是会改变它的值, 但是对他进行赋值毫无意义. 那么, 参数表示的是被传递过来的东西, 这个规则会让程序清楚地多的多. 如果真的需要修改, 那么新定义一个临时变量, 然后进行一次传入值得复制操作, 其实会让逻辑清楚的多.

## 将查询函数从修改函数里分离

明确表现出 有副作用和没有副作用 函数之间的差异, 是个很好地想法.

* 任何有返回值的函数, 都不应该有看得到的副作用. 如果遇到了一个既有返回值, 又有副作用的函数, 那么就应该尝试把查询函数分离出来.

## 替换算法

如果发现了更好的算法, 那就替换它. 比如, 之前写代码, 有个根据 switch 然后给变量不断赋值的操作, 这个操作完全可以用 一个 map 将所有的值进行和 enum 的映射, 然后赋值操作就是简单地 find 操作就可以了. 这种数据统一在一起的做法既显得清晰, 而且后面的取值操作又十分的统一. 这个时候, 替换算法就是非常明智的行为.
