# 原则

* 对软件内部结构做的一种调整, 在不改变软件的可观察行为的前提下, 提高可理解性, 降低修改成本.

重构的目的, 在于使得软件更加容易被理解和修改, 在软件的内部可以做很多的修改, 但是在软件可以观察的外部行为, 必须是很小的变化甚至不变化. 而性能优化, 则是使得代码难以理解, 但是为了性能, 这又是必须做的.

重构的前提, 是不能改变软件的可观察行为. 这是非常重要的.

* 我们希望的程序

1. 容易阅读
1. 所有的逻辑只有一份代码
1. 不危及现有的代码
1. 没有复杂条件的逻辑, 因为已经被分散出去了

* 两顶帽子

添加功能 和 重构.

添加功能的时候, 不应该修改已有代码, 这是添加新功能, 通过测试.
重构的时候, 不应该添加功能, 只管改进程序的结构, 不应该添加任何测试, 只有必要的时候才修改之前的测试.

这两种帽子会经常改变的, 但是, 千万不要在做一点事的时候, 想着另外的一件事. 不然很容易让代码难以控制.

## 为什么重构

### 重新改进设计

代码结构的流失, 是累积性的, 越难看出设计意图的代码, 越难以保护, 于是腐坏的越快.
重构是在整理代码, 让代码回到应有的位置上.

设计不良的程序, 往往需要更多的代码, 因为代码在不用的地方用着同样的语句做着完全相同的事情. 所以, 重构最优先的就是消除重复. 代码量过大, 会让程序越来越难以理解, 而且, 重复的代码最大的问题是, 修改一处不起作用, 因为重复的代码在稍有不同的地方就存在, 要全局搜索之后全局修改. 这对于修改是致命的, 没人受得了每次这样修改代码.

确定, 所有的食物和行为在代码里面仅仅表述一次, 这是优秀设计的根本.

### 更加容易理解

代码是给机器看的, 更是给人看的, 而且那个人经常是几个月之后的你.

重构还能帮助理解之前不理解的代码, 并且在代码简洁之后, 可以看到更加深层次的东西.

### 找 bug

搞清楚程序结构的同时, 可以做一些假设, 把之前bug测试出来.

### 提高速度

良好的设计, 是快速开发的根本. 如果上来就写业务功能, 一开始会进展迅速, 但是恶劣的设计很快会让你慢下来, 因为花在调试和理解原来代码的时间会越来越多, 最终一个个新的补丁, 会让软件开发后期难以维护.

## 重构时机

随时.

### 三次法则

第一次做的时候, 只管去做, 第二次产生反感, 第三次, 重构.

### 添加功能时

首先, 添加新功能, 必须理解老代码, 这个时候, 重构能够帮助理解.
再次, 现有的设计如果无法轻松地添加功能, 那么在为未来添加功能的时候, 会再次面对这个问题, 重构可以节省未来的时间.

### 修补错误的时候

### codeReview

## 难题

### 数据库

数据库的实现, 让重构难以进行.

### 接口

对象, 可以让你分开修改软件的实现和接口. 但是接口是对外的, 修改接口, 经常会导致大量的修改.

如果能够修改调用者, 那么修改接口也不是个问题, 问题是, 对于那些已发布版本的接口, 你是无法控制调用者的. 所以, 这个时候, 你就需要维护两个接口, 这在 api 的代码里面经常出现. 你需要做的就是, 让旧接口, 调用新的接口, 千万不要进行函数的复制.

第二就是, 不要轻易发布接口, 谨慎的对待发布. 发布就意味着不能修改, 哪怕是一个错误的功能, 用户也有可能使用. 一旦开始使用, 那么不再提供就是一个很危险的行为.

### 该重写的时候, 不要重构

有的时候, 代码太混乱, 还不如重新编写代码. 


## 重构和设计

重构和设计相辅相成.

如果没有重构, 就必须保证预先的设计正确无误, 重构改变了设计的角色. 一个合理的设计就能够开始写代码. 这样, 设计就简化了一大步. 灵活的解决方案, 代表着复杂. 最终, 软件也会难以维护. 变化的地方如果过多, 在所有可能变化的地方都建立灵活性, 那么整个系统的复杂度和维护程度都会大大的提高. 如果最后发现, 这些灵活都是没有必要的, 那么就是最大的失败.
这在之前的设计里面有过教训, 原来想要设计一个可配置的功能实现, 在配置项里面, 填写输出方式, 然后在程序里面就可以对应进行输出. 但是, 输出的格式是固定的, 并且过了很久, 在编辑器稳定了之后, 也从来没有更改的需求. 那么, 为了支持这个可配置输出格式, 其实代码里面有着大量的正则解析的. 这样其实是延缓了进度.

## 重构和性能