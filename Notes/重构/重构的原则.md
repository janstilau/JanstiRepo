# 重构原则.

重构: 软件内部架构的调整.(对于你修改的部分, 外部的使用应该完全察觉不到才对). 目的是在不改变软件的可观察行为的前提下, 提高其可理解性, 降低之后的修改成本.
重构的目的是让软件更加容易的被理解和修改
重构有可能会和性能优化相违背, 比如一个循环里面可以做很多事情, 但是会造成代码堆积. 这个时候, 重构成为代码各个目的的小函数可以让代码更加清晰, 但是各个小函数的内部可能每一次执行都要循环一次.

重构的技法之所以重要, 是因为它提供了一种更加高效和受控的代码整理技术.

* 两顶帽子

简单来说, 重构的时候, 不要总是惦记添加新功能. 添加新功能的时候, 不要惦记重构. 当添加新功能的时候, 发现应该重构, 那么就开始重构工作, 在重构好了之后, 在进行功能的添加. 这样分清楚, 可以让功能处于可以回退的状态. 不然, 搅在一起最终出了问题, 想要恢复到可继续的状态都很难.

## 为什么重构

* 改进设计

随意的写代码, 会让原本的设计变得脆弱, 当然, 如果原本有设计才行. 重构能够让代码保持行驶在原本的设计框架之中. 代码的腐烂是有着倍乘效应的, 也就是, 代码越难以阅读, 腐化的也就也快.

设计不良的代码, 需要更多的代码, 修改也更加的困难. 这样结果的原因在于, 设计不良的代码, 充斥着重复, 只是在上下文有了变化. 重构能够让, 所有的事物和行为在代码中只出现一次. 这是优秀设计的根本,

* 理解代码

代码, 主要是给人看的. 一个代码写出来, 重复查看的频率要比修改的频率高的多. 所以, 节省之后的查阅者的时候非常重要, 因为这个查阅者很有可能就是你. 再者, 重构可以熟悉代码, 如果不进行修改, 只是知道了这个代码的目的而已, 而重构, 则可以梳理代码的逻辑, 在重构了一些基本东西之后, 一些结构下的重构, 才会浮现出来.

* 寻找 BUg
* 加快编程
重构梳理逻辑,  让设计处于良好的状态. 而良好的设计, 才是快速开发的根本.


## 什么时候重构

随时, 不应该为了重构而重构, 而是你在想做别的什么事情, 而重构能够帮助你把那些事情做的更好.

* 三次原则

第三次做类似的事情, 就应该重构.

* 添加新功能的时候.

这是时候, 需要我理解需要修改的代码. 只要想要理解代码, 就应该问自己, 能不能对这段代码进行重构. 这样做其实可以加深对于代码的理解. 再有就是, 当添加新功能的时候, 发现原有代码, 难以轻松的加入新的特性. 这个时候, 应该用重构, 弥补之前的问题. 只要完成重构, 那么添加新的特性就会快速流畅.

* 修补 bug 的时候

* 复审代码, codereview 

重构他人的代码, 可以明确的之后, 代码应该是什么样子, 而不是一个概念, 当代码便成为你想要变成的样子之后, 新的问题才会浮现出来. 
最好是一个 reviewer 和原作者一同处理代码, reviewer 提出建议, 然后两人共同判断是否能够通过重构来实现.

## 重构和设计

设计是为了应对变化, 但是变化是在未来发生的, 谁能够预知未来呢.
重构就是随时的调整, 如果昨天的代码不符合现在的设计, 修改就是, 随时进行重构, 也就避免了最终无法改变的情况发生了.

我们想要的程序是 1 容易阅读, 1 所有的逻辑只在唯一的地点指定, 1 新的改动不会危及现有的行为, 1 尽可能的简单表达条件逻辑. 重构的目的就是, 在不改变软件的外观的情况下,  保持上面的状态.

##  所有的问题, 都可以通过添加一个简介层解决.

重构的过程, 其实经常伴随着, 把一个大的对象, 拆解为许多小的对象, 把一个大的函数, 拆解为许多小的函数,  这样, 你需要管理的东西也就增多了, 复杂性也随着增加. 

但是, 间接层有着它的意义

* 允许逻辑共享, 比如子函数的调用
* 分开意图和实现. 也就是类名和函数名能够表达目的, 而内部实现细节.
* 隔离变化
* 封装条件逻辑. 这主要说的是多态, 多态将原来的条件判断, 变成了消息机制, 无论哪种语言, 而消息机制的核心就是, 晚绑定, 在程序运行的那一刻, 才会决定具体的实现是什么.

## 重构问题

* 接口.

对象的作用, 就是分开修改软件的实现和接口. 而重构的时候, 可能就是修改接口. 如果所有的调用者都在你的控制之下, 那么修改接口也无妨, 但是一旦接口已经发布, 比如类库发布之后, 使用者是第三方应用程序, 这个时候, 修改接口是万万不能的. 这个时候, 能够做到的也就是, 同时维护新旧两个接口, 直到所有的用户用上了新的接口. 尽量让, 旧的接口, 调用新的接口, 而不是复制函数的实现.
同时, 要对 public 函数保持警惕, 不要发布的接口, 千万不要发布出去, 一旦发布, 就代表着你失去了控制它的权力. 

* deadline 优先进度.

## 重构和设计. 

不要找出完美的设计, 这是不可能的. 合理的设计 + 事后重构.

## 重构和性能.