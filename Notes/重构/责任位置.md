# 确定责任的位置

## 搬移函数

如果一个类有着太多的行为, 或者和另外一个类有着太多的合作有着高度的耦合, 就应该搬移函数, 这样可以让类保持干净.

具体的改写, 具体分析, 这个做法就是说, 明确类的责任. 对于最开始的那个例子, 影片的价格收到了租用时间和类型的影响, 该开始, 没有类型类, 那么计算价格的函数写在 moive 里面没有问题. 但是后来有了 type 类, 主要目的是为了消除 switch 的形式, 那这个时候, 这个算法就应该转移到 type 类里面, 因为之所以用动态绑定行为, 这个行为就是计算价钱. 在一般的函数里面, 如果这个函数, 大量依赖另外一个对象的属性, 那么这个函数就能够考虑下是不是应该转移到那个对象里面, 这样这个函数取值的过程就是取自己类内数据了. 实际上, 一个函数就应该放在和数据绑定的最紧密的地方.

## 搬移字段

这一点和上面很像, 如果有了一个新的类去完成之前类的工作, 相应的函数和字段都应该转移到新的类里面.

## 提炼类

如果一个类, 里面有着大量的数据的方法, 那么就应该考虑是不是应该将这个类, 分离成不同的类, 每个类专注自己的一部分. 然后用组合或者引用的方式进行组合. 如果一个类的子类, 在进行子类化的时候, 总是影响到一部分特性, 那么很有可能就是基类有着超过了一个变化点, 应该按照变化点切割基类.

这在桥模式里面, 也有很好地说明, 桥模式就是原有类有了太多职责, 导致要兼顾所有的特化子类的时候, 要用相乘的关系来建立子类. 这个时候, 最有效的办法不是什么设计模式, 而是类的功能的分化工作.

## 删除无用类

## 隐藏实现细节

这个其实和封装有些关系. 一个类可能会暴露自己的一个成员变量, 然后客户拿到这个成员变量再去调用成员变量类的方法. 这样的问题是, 客户知道了你的底层实现了, 他这样调用就以为这你之后没有办法修改这层实现, 类的 public 作为接口, 底层实现可以自己变化的优势就没有了. 所以, 可以将暴露成员变量的接口删除, 然后将客户需要的东西, 通过自己定义接口为客户提供. 这个实现自然还是调用自己成员变量的方法, 但是客户不知道这层关系