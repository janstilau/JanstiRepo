# 序言

* 不能指望着读懂代码之后才进行重构, 因为需要重构的代码是非常混乱的, 而能够理解的代码, 重构的价值又不是那么重要. 这个时候, 依靠重构的技法, 安全的修改没有理解的代码就很重要了. 所以, 在重构的过程中应该依靠的是, 坏味道, 坏味道对应的重构技法, 坏味道对应的重构步骤. 这样, 在重构完之后去理解代码的逻辑, 才是可行的.

* 重构是有危险的, 查找坏味道很容易, 但是一味的修改, 会破坏原来写到的稳定的程序. 如果不做准备, 如果不遵守规则, 那么最终, 只会让自己的陷入不敢提交修改代码的大坑里面. 所以, 重构这本书的核心是一个个的技法, 这些技法可以让修改的代价保持在一个可控制的范围之内, 这样, 让重构这件事可以安全的进行. 思想重要, 而技法是保证思想可以正常运转的最基本的元素.

* 重构: 在不改变代码外在行为的前提下, 对代码进行修改, 改进程序的内部结构. 重构就是在代码写好之后改进它的设计. 人们不断地修改代码, 使得根据原来的设计所得的系统, 整体性结构逐渐衰弱. 


## 例子

* 如果, 你发现自己需要为程序添加一个特性的时候, 而代码结构使得你无法很方便的达成目的, 那就先重构这个程序, 使得特性的添加比较容易进行, 然后在添加特性.

* 进行重构的时候, 我们必须要以来测试, 测试应该有自我检查的能力, 将出错的位置清晰的显示出来.

* 代码块越小, 代码的功能就越容易管理, 代码的处理和移动, 也就更加的轻松.

* 函数的参数不应该被修改, 这应该当做一个原则, swift 里面, 参数不能被修改当做了这个语言的特性了. 虽然我们知道, 函数的内部, 参数和局部变量没啥区别. 
在抽取函数的时候, 没有被修改的变量可以当做是函数参数传进去. 只有一个变量被修改的时候, 可以当做返回值返回.

* 重构步骤的本质: 每次做完修改之后, 都要进行编译测试. 由于每次修改的幅度都很小, 所以任何错误都很容易发现. 用微小的步骤修改程序, 如果发现了错误, 那么很容易就能够修正.

* 好的代码应该清楚表达出自己的功能, 变量的名称是代码清晰的关键. 为了能够提高代码的清晰度, 可以大胆的修改之前定义的名称. 前提是, 英语能力. 代码应该能够表现自己的目的, 这是非常重要的原则.

* 绝大多数的情况下, 函数应该放在它所使用的数据的对象内 ==> MoveMethod 技法.
在MoveMethod之后, 如果原来的函数是一个 public 函数, 那么让它调用新函数, 如果不是, 那么可以直接在类的内部进行替换.

* 关于 switch. 最好, 不要在另外一个对象的属性基础上运用 switch 语句, 如果不得不使用, 也应该在对象自己的数据上使用, 而不是别人的数据上使用. 原因很简单, 增加一个 switch 的 case 值, 所有用到的地方都要改. 而在内部使用, 只用修改一个地方就可以了. 如果功能需要其他的参数, 那么就传进去.

*  当出现 switch case 的时候, 如果代码太过于复杂, 可以考虑 分解成各个小函数 和 子类化的方式. 子类化的方式, 能够真正把代码分到各个类中, 但是, 需要注意的是, switch case 是不能够消除的. 就算是子类化的方式, 还是要通过 switch case 方式生成各个子类, 然后在其他函数里面通过子类对象的多态性达到目的. 
到底需不要要子类化处理 swtich case 需要自己把握, 如果一个内部, 很多函数都要通过 swtich 进行处理, 那么子类化是给这个类降压的很好的办法, 但是如果只是一个函数里面用到了 switch, 我觉得用分解函数的办法就够了.
对于 switch 所在类的外界来说, 不应该察觉内部的变化. 就算用了 策略模式或者状态模式, 根据 switch 生成不同的子类对象, 这个过程也应该在 switch 的内部, 这样, 就算要增加新的 case 的话, 也仅仅是增加一个子类, 以及 在 switch 所在类里面增加一行代码的事情. 增加了一个 case, switch 所在类是必然要有所变化的. 但是, 使用这个类的其他地方, 变化能够降低到很小.

* 重构的原则就是: 小修改, 测试, 小修改, 测试, 这种节奏才能让重构快速安全的运行.
