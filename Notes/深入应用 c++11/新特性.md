# 新特性

## auto

不同于动态语言运行时变量的类型推到, 隐式类型定义的类型推导实在编译期. 编译期自动推断出这个变量的类型, 所以书写的时候, 不需要显示的指定.
auto 并不是代表一个实际的类型声明, 只是一个类型声明的占位符的作用. 使用 auto 的变量必须初始化, 以便编译期推断它的世纪类型.

* auto的推导规则

当不声明为指针或者引用的时候, auto 的推到结构和初始化表达式抛弃引用和 cv 限定符后的类型一致.
当声明为指针或者引用的时候, auto 的推到结果会保持初始化表达式的 cv 属性.

上面这些太麻烦了, 写代码的时候, 如果你要一个指针, 就 auto *, 如果要一个引用就 auto &, 如果不让改就 const 加前面. 如果本来就是指针, 那么 auto 就是一个指针类型, 但这个时候写 auto *也不会报错, 只不过 auto 变成了指针所指类型. 但是 auto 的右边表达式如果是一个引用, 这个引用会丢失, auto 变成了原始类型, 所以, 如果想要指针或者引用, 就明确的写出来. 不要靠记忆去分析 auto 到底是什么. const 就明确写出来.

``` cpp
int value = 10;
const int &ref = value;
auto backup = ref; // backup 会成为一个 int, 舍弃 const
```

* 什么时候用 auto

当写类型信息的时候太麻烦的时候, 虽然 static 也能用 auto, 但是, 为什么要用, 为了用新特性代码的可读性要下降吗.

## decltype

auto 是通过表达式在编译的时候来确定变量的类型, 所以必须有初始化. decltype 则是在编译的时候, 推导出一个表达式的类型. 用法和 sizeof 一样.

```cpp
int x = 0;
decltype(x) y = 1;
decltype(x + y) z = 0;

const int &i = x;
decltype(i) j = y; // j -> const int&
decltype(x) *p = &x;
decltype(p) *pp = &p;;
```

decltype 可以通过表达式精确地得到类型, 不会像 auto 会舍弃某些东西.

并且, 可以在结果上进行推导, 例如上面合成了一个 int *, 并且还能正确的获取到 int 指针类型之后, 向后合成二级指针. 注意, 如果赋值的类型, 和左边推导的类型不相符, 编译的时候是会报错的.

* 应用

一般用在泛型编程里面.

根据传入泛型里面类型, 定义变量.

typedef decltype(sizeof(0)) size_t

还有就是根据参数推导出返回值的类型, 这里有点晦涩.

## 模板的改进

* `> >` 之间的空格消除了, 在写模板的时候, 两个>可以写在一起了.

* using func_t = void(*)(int, int) 已经可以完全替代 typedef 了, 而且写法更加的合理.

template <typename _Value>
using stringMap = map<string, _Value>;

stringMap 既不是一个类模板, 也不是一个函数模板, 而是一个模板别名.






















