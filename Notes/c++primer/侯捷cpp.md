# Cpp

## Cpp类设计注意点

* 构造函数的初始化列表
* pass by value, pass by reference. return by value, return by reference.
* 成员函数的结尾, 是否用 const 进行修饰.
* by reference 传值进行 const 修饰吗

    C++ 中对于 const 有着严格的定义. cosnt A *aPointer; const A& aRef;  A 中有一个成员变量 value, 那么 aPointer->value, aRef.value 都是不能够修改的. 这其实是符合 const 在原始数据类型的定义的. 而 OC 中, aPointer->value 却能进行修改, 这是 OC 中不好的地方.

    当一个指针, ref 被 const 修饰了之后, 只能调用被 const 修饰的函数, 如果没有 const 修饰的话, 就会报'this' argument to member function 'speak' has type 'const A', but function is not marked const', 这是编译的时候就报的错. 所以, 编译器其实做了限制, const 的函数是不能对于成员变量进行修改的, 在 const 函数的内部也不能调用非 const 修饰的函数, 这样, const pointer, ref 调用 const 函数, 就能够保证说, 内部的状态一定不会被修改. 

    而非 const ref, pointer, 是可以调用 const 函数的. 

    相对应的, OC 里面对于状态保持不变这个事情, 是通过接口实现的, 也只有几个系统的类做了不可更改的操作, NSString, NSArray, 它们不可以修改, 是因为它们就没有修改内部状态的接口. 至于用 OC 的动态性修改内部数据会不会报错, 没有试验过.

* 操作符重载, 模拟基本数据类型的操作符操作.
操作符重载包括类内操作符函数, 以及全局操作符函数.
* 成员变量是否有指针, 这
如果有指针, 那么该类就要负责这个指针指向对象的生命周期的管理. 而为了应对这个责任, 拷贝构造函数, 拷贝赋值函数, 和析构函数, 都要进行实现.
实现的基本思路在于, 判断是不是原有管理的资源, 对于原有资源的释放, 对于新的资源的深拷贝.

这里和 OC 有着很大的区别, 首先 OC 中所有的资源都是在堆中, 在这 OC 中所有的资源都是用的引用计数进行管理的. OC 中没有拷贝构造函数的概念, 要有类似功能的类, 必须实现 COPY 协议. OC 也没有拷贝赋值函数的概念, OC 中的赋值仅仅是指针的赋值而已. 其实在 C++ 的=操作符中, 对于指针也仅仅是指针变量的赋值, 拷贝赋值的操作, 只有在栈上的对象进行赋值的时候才会发生.

OC 的 copy 函数中, 对于指针的成员变量, 要考虑深拷贝和浅拷贝的问题.
C++ 的拷贝构造和拷贝赋值中, 也要考虑这个问题.
对于 C++ 中, 几乎都是深拷贝. 这是因为, 在 C++ 中, 没有默认使用引用计数的概念, 除非明确的使用 sharePointer. 这样, 类就有管理自己成员变量的内存的责任, 类在自己 dealloc 的时候, 就要释放管理的成员变量指向的内存. 而这在 OC 中, 因为所有类的有着引用计数的存储, 所以就算是浅拷贝, 因为引用计数加1, 成员变量指向的资源可以得到很好地管理.

现在 C++ 推荐使用引用计数进行资源的管理.

## 内存.

new -> 1. 系统先分配内存, malloc 2. 调用构造函数初始化
delete -> 1. 调用析构函数 2. free对象占据的空间

构造函数是没有虚函数的, 这也是为什么 C++ 里面, 没有类似 init 这样的一个东西, NSObject 写出来了, 子类直接 init 就可以了. OC 是没有办法避免子类通过 init, 而不是自己写出来的指定的 init 方法进行初始化的. 因为 OC 是个消息机制, init 不过是类的一个方法而已, 实际上, 可以多次调用 init 方法的. 而 C++ 中, 一个类只能通过自己写出来的构造函数进行初始化. 而初始化的继承体系, 是要在各自的初始化方法里面明确的写出调用父类的哪个构造方法在保持的.

OC 中想要保持这个继承体系, 必须重写 init 方法, 在各个方法里面, 写明调用 super 的哪个 init 方法才可以, 不过这个体系我们经常不刻意去维护.

### 内存分配的真正内存分布.

VC 下的内存分布策略
Cookie (debug信息, release 模式没有) 实际的内容 (pad信息, 为了保持各个系统分配内存的策略, 比如VC下必须保持分配的总共空间必须是16bit的倍数) Cookie
在分配数组的情况下,  array new, array delete.
Cookie (debug信息, release 模式没有) 一个数量值,代表数组的长度 实际的内容 (pad信息, 为了保持各个系统分配内存的策略, 比如VC下必须保持分配的总共空间必须是16bit的倍数) Cookie
所以在 array new 的时候, 其中是有一个值是代表着数组长度的, 这样, array delete 的时候, 可以根据中间的数量值, 对实际内容依次调用析构函数. 而在析构函数里面, 可能会有其他的内存释放的操作.
array new, 必须搭配 array delete, 如果只是调用 delete, 那么只会调用一次析构函数.
数组的空间是可以正确的释放的, 因为 cookie 中记录了这段内存空间有多少, 泄露的是, 数组的各个 item 管理的内存空间, 这些内存空间只有在析构函数中才会被释放. 如果各个 item 中, 没有指针成员变量, 也就是没有管理另外一块内存空间, 也就不会发生内存泄露. 但是, 不应该去分辨这个

Cookie 中记录了整个分配出来的大小, 这样, free 的时候, 就可以根据整个 Cookie 值, 回收对应的内存空间.



