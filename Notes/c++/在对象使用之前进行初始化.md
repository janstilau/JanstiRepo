# 初始化

永远在使用对象之前, 先将它进行初始化, 对于没有任何成员的内置类型, 必须手工完成此事. 对于内置类型之外的类型, 初始化的责任在于它的构造函数之中. 也就是构造函数要保证每个成员都能正确的初始化.

在构造函数里面赋值, 并不是初始化行为. 对象的成员变量的初始化动作, 发生在进入构造函数本体之前. 在构造函数里面进行的 = 操作是赋值, 这也就解释了之前思考的, 为什么在构造函数里面用 = 会引起成员变量类型的 operator= 函数被调用.

用 member initialization list 进行初始化操作. 上面的赋值操作, 其实是, 每个成员变量首先调用自己的 defalut 构造函数, 为每个成员变量赋值, 然后调用 assign 操作, 而 member Initialization list, 则是拿传入的值调用 copy 构造函数. 也就是说, 如果没有 member initialization list, 一定会调用 defalut 构造函数为每个成员变量进行初始化操作的. 

所以, 总是应该调用 成员初始化列表的方式, 描述构造方法, 并且应该在这个列表里面列出所有的成员变量, mName() 这种写法, 其实就是调用 String 的默认构造函数, 但是这样明确的写出来, 会避免忘记哪些成员变量无需初值哪些必须赋初值, 而导致真正需要赋初值的成员变量忘记被初始化. 如果, 有多个构造函数, 每个都写 成员初始化列表 确实太啰嗦, 可以编写一个 private 方法用赋值语句进行统一的初始化操作. 不过, 这样其实不是初始化, 而是用赋值代替初始化操作了.

注意, c++ 里面的构造函数是不能调用其他的构造函数的, 这样仅仅是在构造函数里面, 用其他的构造函数又生成一个对象而已, 原有对象的值是不会有改变的. 所以, C++ 里面, 是没有一个 全能初始化方法, 作为所有参数配置的集合体, 供其他初始化方法调用的.