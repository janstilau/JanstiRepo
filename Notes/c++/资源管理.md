# 资源管理

所谓资源就是, 一旦用了它, 那就将来就必须还给系统.

## 对象管理资源

如果我们手动管理资源, 那么很有可能在释放资源代码生效前, 程序提前退出了这个代码段. 理由很有多, 提前的 return, continue, break, 或者发生了异常. 这些都会引起释放代码不会生效.
并且, 在每一个函数的退出点, 添加这些代码会让代码丑陋而且难以维护. 之后维护人员可能想象不到这里有资源管理的问题, 而这个维护人员很有可能就是编写这段代码的人. 在每个地方添加同样的代码, 也让代码显得冗余.
用对象管理资源, 是建立在对象的构造函数, 析构函数 和 copy 函数(拷贝构造, 拷贝赋值)上, 在这些函数里面, 分别建立对于资源的获取, 以及释放操作. 对于可以复制的资源管理类, 里面可能是引用计数增加, 例如 share_ptr, 也有可能是对原有资源的深拷贝操作. 但不管怎么说, 资源管理类对象提供的操作资源的代码, 是和对象的生命周期连接在一起的, 而这套机制, 大大的减轻了程序员要时刻铭记资源管理的负担.

最常见的资源就是内容, 现在由 share_ptr, unique_ptr 可以进行管理. 除了这些, Locker, File 这些原来需要明确的写出释放操作的场景, 类的析构里面都添加了相应的释放操作.

一般来说, 这些资源管理类的资源, 要在获取资源的时候, 立马和资源管理类进行绑定. 例如, share_ptr<int> pointer(new int(100)), 这是为了防止资源泄露, 因为 new 出来的指针, 如果暴露给外界, 那么外界很有可能进行某些操作. 这样有可能把自己生命周期的操作权交给了外界.

## 资源管理类的 copy 行为

这是编写资源管理类的人要进行考虑的, 资源管理类可不可以调用 copy 行为的函数. 拷贝构造, 拷贝赋值.

* 禁止copy. 例如 锁对象
* 引用计数. share_ptr
* 深拷贝. 需要用到, 自己实现.
* 移除所有权操作. 例如 unique_ptr 的 release 会返回原始指针, reset 方法会接受一个指针, 释放自己的操作的指针后, 管理 reset 参数的指针.

## 提供原始资源的访问

资源管理类是管理内存分配的, 但是真正用到资源的时候, 还是要用包装的数据才能够取出里面的数据. 这个时候可以明确的提供一个返回原始指针的行为, 例如 get, 或者 qt 里面的 data, 或者重载 *, -> 操作符. 总之, 要提供访问数据的接口给使用者, 毕竟内存管理只是行为的一部分

## new[], delete[] new delete 要成对出现

new 是先分配内存, 然后调用构造函数, delete 是先调用析构函数, 然后回收内存. 数组形式的则是调用多个构造和析构函数. 这里面, 是不能进行交叉的. 一般来说, 数组行为会在分配的内存里面, 记录这次有多少个对象, 所以, 析构的时候也会调用那么多的对象析构, 这个行为, 只能是 delete[] 引起. 如果交叉调用, 行为未定义.

## 独立的语句包装资源管理对象和原始对象的绑定

例子是 dummy(share_ptr(newint (100)), getId())
这个函数调用里面, 有三个操作, getId, new int, share_ptr 的构造, getId 的什么时候被调用, 在 c++ 里面没有明确的规定, 因为这是一个语句. 如果, new int, getId, share_ptr构造这样的顺序, 有可能 getId 抛出异常, 然后 new Int 的原始指针还没有被 share_ptr 管理, 这里的资源就泄露了. 所以, 明确的写出 share_ptr(newint (100)), 传入 dummy 的是 share_ptr 的对象, 这样是多语句执行, 就不会出现这种未知的结果.

## new 的分解

new :
void* mem = operator new( sizeof(ClassName)); -> 里面调用了 malloc
pc = static_cast<ClassName*>(mem);
pc->ClassName::Constrtuct(para_1, para_2); // 这里, 又变成了->的调用, 所以, 构造函数里面, this 就是 pc.

delete:
ClassName::~Destructurt(pc);
operator delete(pc); --> 里面调用了 free

## malloc 和 free 到底分配多少内存

调试模式下:
会有调试模式的一些信息, 然后是你需要的内存, 然后还有 cookie, 这个 cookie 保存整块系统给你分配的大小, 这个 cookie 开始有一个, 结尾有一个, 然后如果这块内存不是 16的倍数, 还会有 pad 空域信息, 这些只是为了分配的空间对齐.

release 模式:
出去调试模式的信息, 还是有 cookie 和空域信息.

也就是说, 再分配内存的时候, sizeof 得到的, 只是有效值的信息, 在这些有效信息之外, 系统还有有些附加信息, 为了调试, 为了记录信息方便回收, 为了调整分配单元的位置.
当 new array, delete array 的时候, 在分配的内存空间里面, 会多一个 int 值, 这个 int 值记录了这个数组里面有多少个元素, 根据这个元素, 系统才知道, 要调用多少个构造函数, 析构的时候, 要进行多少次析构函数. 所以, array new 的时候, 如果只用 delete 会有问题, 因为系统不知道有多少个元素, 这样的行为, 是没有定义的. 经验上来说, 只会调用一个析构函数. 我们常说, array new, delete 会造成内存泄漏, 就是指的没有调用后面元素的析构函数, 导致这些元素管理的内存发生了泄露. 而本身这个数组所占用的内存空间, 因为有 cookie 的存在, 是不会发生泄露的.