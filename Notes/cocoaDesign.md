# cocoa设计模式

## 模板方法.

不要调用我, 让我来调用你.
模板方法简单来说, 就是一个固定的算法, 在这个固定的算法里面, 会有很多的函数调用. 子类可以重写这些函数, 来达到自定义的作用. 那么, 这些函数就是一些应用开发人员不知道什么时候会被调用的函数, 应用开发人员完成了函数的重写之后, 能够做的就是等待框架开发人员的调用.
一般来说, 框架开发人员会设计好算法, 比如, dealloc, drawrect 方法, 这两个方法, 一个是在引用计数变为0之后, 自动调用. 一个是在 runloop 中, 会对每一个设置为需要刷新的 view 进行drawRect 的调用. 这些机制, 都是在其他的算法里面写好的, 其实文档也就是这样的功能, 讲述那些方法什么时候会调用, 有什么样的作用, 但是文档里面很少讲具体的算法到底是什么运行机制. 这是类库的核心商业代码, 并且解释这些东西过于复杂.
其实这个设计方法平时用的非常多, 例如直播间的消息模型, 在发送消息的时候, 和接受消息的时候, 会进行归档解档的操作, 而归档接档的操作, 就是一个模板方法, 首先父类会进行公共操作的归档解档, 然后子类只是会对 liveMsgInfo 字段进行解档, 只是对自己的业务参数归档到 liveMsgInfo 里面, 所以, 所有的子类, 都会重写 encodeToBusniessInfo , 和 decodeFromServer 这两个方法. 那么父类进行的是通用算法的设计, 子类进行的是需要自定义的方法的设计. 不过平时我们写的方法没有那么复杂, 所以对于这个设计模式的感觉没有那么强烈.

* 变化点

子类按照自己的功能, 重写模板方法里面的一个或者几个方法

* 不变点

父类的算法应该保持不变, 算法里面按照固定的步骤调用方法, 而方法会被子类进行重写. 父类应该写出默认的方法实现, 这样不必所有的子类都要将模板方法里面的调用的方法全部进行重写.

### display 方法的作用

display method configures the graphical coordinate system, implements graphical “clipping” to constrain drawing to the area where view is allowed to draw, calls the –drawRect: method to actually draw, and then sends –display to any subviews nested within the view.

这个方法对于每一个 view 来说, 算法都是一样的, 不一样的就是 drawRect 的实现. 这其实是和复合模式是有关系的, 复合模式, 让单一的 view 和复合 view 都有着同样的接口设计, 这样 display 就可以用接口操作对象. 这里其实也是为什么 drawRect 方法不能直接调用的原因, 它的调用, 是需要上下文的. 所谓的上下文, 就是一系列的变量, 设置等. 在弹幕的第三方库里面, 上下文被当做一个对象进行传递, 这个对象里面有着弹幕的一些设置, 例如大小, 透明度. 而在 drawRect 里面, 上下文是一个全局对象, 是一个栈的结构. 当前的上下文里面在栈顶. 这也是一个对象, 里面详细的记录了当前绘图应该使用的宽度, 颜色等信息. 所以, 直接调用 drawRect 是会丢失这些信息的, 不能直接调用.

### 问题

1. 需要子类化, 而子类化是强耦合的. cocoa 里面有很多可以避免子类化的方案, 例如代理方法, 例如监听者模式. 这些都是在某些操作发生的时候, 可以提供自定义操作的模式, 而 template method 子类化的目的, 也是为了提供自定义的方法实现. 
1. 文档困难. 单独的写出每个模板子方法的目的, 不能让阅读者知道整个系统框架的运转流程. 每个子方法, 要不要调用父类的方法, 一般来说, 都是必须调用, 哪怕父类是一个什么都不做的实现. 现在, cocoa 在复写方法的时候, 如果不调用父类方法会明显的警告你.
1. 想要自定义算法十分困难.

所以, 模板方法只用于那些算法十分稳定的地方. 

## 单例模式

为什么在 OC 里面不直接用类对象, 而是要创建一个单例呢?

首先是存储的问题. 类对象是没有存储空间的, 只能用 static 的方式才可以, 但是 static 是一份公用的空间. 如果想要子类化呢, 如果写一个子类, 那么父类和子类其实是公用了一块内存空间的, 这样操作起来, 一个子类的调用, 有可能污染父类的空间.
再者是硬编码的问题, 用类对象, 那么每一个调用, 其实都是要写出明确的类的信息才行, 那么如果要变化单例的实际类型, 就要改变很多很多的调用的代码. 而如果是用接口 + 子类的方式, 只是在赋值的时候改变一下实际的生成对象代码就可以了. 不过这个很难出现, 一般来说, 我们用单例, 是不会进行子类化的.

### 具体实现

一般来说, 我们只会去实现 defaultxxx 和 sharexxx 方法, 不过, 真正实现单例, 其实要复写某些方法, 来避免使用者 alloc 一个新的对象. 所以, 每一个会产生实际对象的方法, 都应该复写来保证对象只有一份.

这个模式是最简单的设计模式, 提供一个访问接口, 在这个接口里面创建实际的对象, 然后将有可能实际创建对象的方法进行重写(虽然一般都懒得做). 这个模式最大的问题是, 不要过多使用. 有些类的对象确实只会出现一份, 它会在一个单例里面, 或者程序的整个运行周期, 只会有一个该类的对象出现. 例如, 直播间 vc , 现在的逻辑是, 整个 app 只有一个直播间 vc, 那么直播间 VC 里面的所有的属性, 都只会出现一份. 那么这能算作是一个单例吗. 显然不可以. 或者, rootVC, 一个对象只会出现一份, 这应该是单例吗. 自然是不可以.


## target action

这个模式, 其实就是监听者模式, 不过在监听者模式上增加了一些 cocoa 自己的实现.

问题的提出, 是一个 view 控件, 会伴随着控件状态改变的某些操作. 最典型的自然是按钮了, 当按钮被点击了之后, 要有一些业务代码要进行调用. 这个时候, 这个调用写到哪里是一个问题. 如果通过子类化的方式,  进行 view 的自定义点击调用, 就会出现, 一个功能, 就要有一个 Button 的子类. 那么就会出现类爆炸的情况. 但这还不是最主要的问题, 最主要的问题就是, 点击之后的操作, 应该是在 controller 层的逻辑, 而现在写到了 view 层. 而 view 层是不会清晰的之后操作对应的数据的. 为了 view 层里面可以写出对应的操作逻辑, 要传递大量业务相关的数据到 view 里面. 那么这个 view 就不可能会有复用的机会了.

### Outlet

书中讲述了一下关于 apple 的 interfaceBuilder 的实现原理. xib 自然是一个 xml 文件而已, 在 loading 的过程之中, 会调用 owner 的 set 方法, 将之前的连线构造成为一个内存的模型. 这个构建的过程, 是系统框架自动完成的. 这种从 xib 中连线而成的成员变量, 就是 Outlet 变量, 这种变量, 在调用代码初始化的时候, 是空的, 只有调用 loading 初始化, 才会由 loading 系统, 自动的赋值成为 loading 过程中创建的对象.
在所有的 loading 过程完成之后, 会调用 awakeFromNib 方法. 在这个方法内部, 就可以认为所有的 loading
的过程已经完成了, 可以继续做一些自定义的初始化的操作了.
需要注意的是, loading 过程中 set 方法的调用是不可控的, 所以不要期望一些顺序相关的代码会正常执行.


### target-aciton

监听者模式想要实现应该是什么结构, 首先, 要有一个借口, 这个接口是在 view 状态改变的时候, 应该调用的方法. 然后, view 里面会维护一个列表, 这个列表都是这个接口对象, 这样, 在 view 状态改变后, 遍历这个列表, 然后调用这个接口就可以了. target - action 做了一些 apple 相关的设定, 由于消息机制, 这种非常动态化的设置, 接口只需要函数签名, 而不需要函数名, 也就是说, 只需要确定, aciton 是一个 void 返回值, 接受一个参数, 或者0个参数的 selector 就可以了. 那么这样, 就可以解除了对于 aciton 的限制, 可以随意命名了. 再者, target 参数也不是必须的. apple 在明确知道 target 的情况下, 会调用这个 target 的 action 方法, 在 target 为 nil 的情况下, 会从现在的响应者控件开始, 顺着响应者链条, 一步步的去询问, 下一个响应者有没有实现这个 action , 如果有的话, 那么就是该响应者调用 action 来进行业务的处理, 这样, 一个 view 的状态改变的处理, 连 view 都不必清楚, 系统会自动的将没有被处理的事件, 通过响应者链条, 汇集到最通用的响应者中, 由这个类进行最终的处理操作.
这里其实是通过 NSApplicaiton 进行了一次调度. 当 NSControl 的事件发生了之后, 它会调用 sendTarget:action 方法. 这个方法的内部, 其实会调用 NSApplication 的 sendAction to from 函数. 在因为 NSApplciaiton 有掌握这个 app 最基本的信息, 所以它其实知道, 现在的响应者是谁. 如果 to 为 nil 的话,  它会能够进行之前所说的响应者链条的动态处理. 
一个事件的处理过程, 其实是 "硬件操作, 系统中断, 操作系统捕捉事件, 操作系统包装成事件传递给应用程序, 应用程序捕捉事件, 应用程序调用 sendEvent 函数, sendEvent 函数会确定时间的接受者、对于键盘事件是第一响应者、对于鼠标或者屏幕点击事件则是通过 hitTest 和 pointInside 函数确定最适合的 view, 事件的接受者内部对事件进行处理、UIControl对象会记录事件的状态, 当事件处理发现特定的 UIControl 事件发生了之后(UIEvent 和 touchUpInside 事件不是一回事, TouchUpInside 是 Butoon 内部记录点击拖动离开这一系列动作之后自己判断的 touchUpInside 发生)会判断特定的事件有没有target 和 aciton然后调用 sendTargetAction 方法, UIApplication 会接管消息处理的流程要么是直接调用要么是通过响应者链条进行寻找 target 的操作".

### 其他平台的事件处理

因为 oc 的语言动态性, 可以发送消息, 使得解析事件变得异常简单. 其他的平台, 其实是需要解析事件, 通过一个 int 值, 进行分辨操作. 这其实在直播间消息模型处理里面有过提现. 其实, 在直播间的消息生成的时候, 可以通过 OC 的动态性创建各个消息类的实际对象, 不过在那里还是选择了通过 liveMsgType 一步步进行解析的操作.  原因主要在于, 一步步解析其实可以通过代码体现思路, 而用动态性创建对象方便的同时, 把消息处理的思路完全覆盖了.

qt 的信号槽机制和 target aciton 很像, 不过需要 metaObjectCompiler 的预编译才能够执行, 原因在 C++ 的静态编译的特性. cocoa 的 view 类很少进行子类化, target action 提供了非常大的扩展性, 子类越少, 那么思考的复杂程度也就越少. 除了 target action, 代理和通知, 也减少了子类化的需求.

## 归档解档

归档解档和序列化是一回事.

归档解档可以用于深拷贝.

需要注意的是, 归档解档应该是循环的, 一个对象的内部属性, 也应该调用归档解档的方法. 每个类都有着自己的归档解档方法, 在自己的方法里面, 调用属性对象的归档解档方法, 而属性对象自己的方法里面, 又是自己属性的各个归档解档的分支.

每个类决定自己那个成员变量进行归档解档, 对于计算属性, 可以不参与这些运算, 而对于状态属性, 如果没有参与到这个过程, 那么解档之后的数据就有可能不完整.

