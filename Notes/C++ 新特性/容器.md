# 容器

容器的大小都是固定的, 这些固定的大小, 一般是指针组成的, 这些指针指向一片内存区域, 在那个区域里面, 存放着真正容器所管理的数据. 所以, 容器的大小, 和它现有的存放的数据, 是没有关系的.

## 迭代器

struct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};
struct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};
struct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {}; 单向
struct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {}; 双向
struct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {}; 随机

迭代器 associated type. 必须定义, 为了算法的提问.
typedef ptrdiff_t difference_type; // 距离 ptrdiff_t ==> unsigned long
typedef bidirectional_iterator_tag iterator_category; // 分类
typedef T value_type; // 所指 type
typedef Ptr pointer;
typedef Ref reference;

traits(特质, 性格) 萃取机

迭代器, 是算法和容器之间的桥梁.
算法首先要知道范围, 所以容器都会把 begin, end 返回的迭代器传递进去.
算法在操作的过程中, 需要知道迭代器的一些特质, 才能做相对应的操作.
一般来说, 在一个迭代器类型中, 都要有着上面五种 typedef, 其中value_type, iterator_category, difference_type 会被算法进行提问, 而 pointer, reference, 一般用在迭代器类内部实现的类型定义上.

算法的提问, 一般是这样的一个过程. 如果算法提问, 没有对应的回答, 那么编译就会失败. 所谓的提问, 现在看就是通过迭代器的 typedef 取类型.
得到了 I 是 iterator 的类型, 然后 I::iterator_category 就是分类, I::difference_type 就是迭代器的距离. 然后就可以用得到的类型, 比如 I::iterator_category(), 制造一个临时对象出来. 这个临时对象的作用, 仅仅是为了函数重载. 例如, I::iterator_category 是一个 random, 代表着这个 iterator 支持随机访问, 那么算法就可以将操作分发到另外一个函数, 通过最后制造出来的临时对象做分发的依据, 分发进去的函数, 就知道这个 iterator 可以进行随机访问, 也就可以进行相应的操作了.

但是, 如果 iterator 是一个 native pointer, 那么就没有办法做 typedef 了, 也就是算法没有办法通过::这种方式进行询问了. STL 为了应对这种情况, iterator_traits 被创造出来了. 这是一个模板类, 类型参数传入 iterator. 在这个类里面, 又有上面五种 typedef. 如果传递过来的是一个类型, 那么这五种 typedef, 就是用传递过来的 iterator 的 typedef. 然后对这个模板类进行了特化, 如果发现, 传过来的模板类型, 是一个 native pointer, 那么iterator_traits 的 typedef, 会变成指针指向的类型. 这样就解决了指针不能 typedef 的问题. 通过增加了一个中间层, 使得不能 typedef 的 native pointer, 用中间层实现了效果. 对于 native 指针, iterator_category 的都是 random_tag.

### 迭代器的分类

Array 随机
Vector 随机
Deque 随机
List 双向
Forwardlist 单向
红黑树相关 双向
哈希表相关 根据每个桶的链表是不是双向

算法根据迭代器的 typdef 做的分发, 全部用的函数重载的方式, 这也就是为什么分类都用类型来进行表示的原因. 因为用的是函数重载的方式.

不同类型的迭代器, 会对效率有很大的影响, STL 的 distance 函数, 传入头尾迭代器, 根据分类的不同, 如果是 random 的 iterator, 直接相减, 对于不是的, 需要头迭代器一步步走尾迭代器, 返回步数.

在 STL 的算法里面, 询问 iterator_traits 的 Iteator_category, 生成临时对象, 根据临时对象, 将操作分发到相应的子函数, 是非常普遍的操作.

例子不用多举例, copy, destroy 的实际实现非常复杂, 对于平时写代码也没有借鉴.

算法对于传入的类型参数, 是没有限制的, 因为是泛型, 所以在命名的时候, 有了很多的暗示, 一般来说, 就是迭代器分类的时候, 类型参数加上了分类的前缀.

## List

环状双向链表.
特地在环状 list 的尾部, 增加一个空白节点, 用来符合 STL 的前闭后开区间. end 就指向这里.

``` CPP
template<typename T>
struct __list_node
{
    typedef void *void_pointer;
    void_pointer prev;
    void_pointer next;
    T data;
};


template<class T, class Ptr, class Ref>
struct __list_iterator
{
    typedef __list_iterator<T, Ptr, Ref> self;
    typedef __list_node<T>* link_type;

    typedef ptrdiff_t difference_type;
    typedef bidirectional_iterator_tag iterator_category;
    typedef T value_type;
    typedef Ptr pointer;
    typedef Ref reference;


    link_type node;

    reference operator*() const{
        return (*node).data;
    }
    pointer operator ->() const {
        return &(operator *());
    }

    self& operator ++() { // int i = 9; ++(++i)成功, (i++)++失败, 为了模拟整数, 所以, 前++ 返回的都是引用.
        node = (link_type)(*node).next;
        return *this;
    }
    self operator ++(int) {
        self temp = *this; // 这里是拷贝构造函数, 要注意, 这里 * 是作用于 this 上面的, 不是 *(*this) 上面, 所以不会调用 * 操作符
        ++*this; // 这里会调用上面的前++
        return temp;
    }
}


template <class T, class Alloc = alloc>
class list {
protected:
    typedef __list_node<T> list_node;
public:
    typedef list_node* link_type;
    typedef __list_iterator<T, T&, T*> iterator;
protected:
    link_type node;
}

```

对于链表来说, iterator的++操作, 要让 iterator 顺着链表的走向, 指向当前 iterator 当前指向结点的一下个结点. 我们这里用指向, 是因为 iterator 就是为了模拟指针, 而存在的一种数据类型. 所以, iterator 里面要有大量的操作符重载.

在上面的代码, 我们可以看到, 在 STL 的类中, 有着大量的typedef. 所以, list::iterator 和 其他容器命名空间的 iterator, 根本就是两个类, 有着不同的实现. 这里, iterator 并没有用接口的概念进行强制规定必须实现哪些方法.