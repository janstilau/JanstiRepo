# 分配器

## 面向对象和泛型

C++ 中, 面向对象是说, 一个类有数据, 有方法, 将数据和方法放到一起, 完成数据和行为的封装. 而泛型编程的思想是, 将所有的数据, 看做一个可以操作的类型, 然后用统一的方法, 操作所有的数据. 这两种思想, 必然是不同的. 但是泛型又不不可避免使用的, 因为, 算法确实是一个通用的结构, 排序, 找最大, 找最小, 都是用一套算法就能够得到最后的答案, 类型仅仅提供一个比较函数就可以了.

而在实现上来说, 不同的容器的内存实现是不一样的, 有的可以随机存储, 有的可以向前遍历, 一套算法想要面对所有的容器进行操作, 是不可能的事情. 所以, 在算法和容器之间, 有了迭代器这个角色. 迭代器又叫泛型指针, 不同的容器, 提供自己版本的迭代器, 而这些迭代器, 有着同样的接口, 那就是 *, ++, 有的还有-- 和夸距离赋值. 实际上, 迭代器是将内部容器的底层实现, 进行了一次包装, 这样就使得算法这一个层面, 可以通过迭代器编程, 用一套统一的算法结构, 适用所有的容器.

而容器本身又是泛型的. 这里的泛型, 主要是类型的不同, 容器本身的方法, 是建立在自己的数据结构上的, 那就是连续的数组, 链表, 双向链表, 红黑树, 哈希表, 这些操作实际上和自己存放的是什么类型是没有什么关系的. 所以, 容器的泛型, 更多地是为程序员进行服务的.

## operator new

new 最终还是调用了 malloc. 相应 delete 会调用 free.

## malloc

malloc 在分配内存的时候, 会加一些 overhead, 其中 debug 的时候, 会增加一些 debug 的信息, 所以 debug 确实是耗费资源. 除此之外, 在头尾还会有指示这次分配的内存到底有多大两个内存块, 还有一些其他的信息忘了是什么了. 这些信息是固定的, 所以, 如果你要的内存大, 这些额外的信息所占的比例就小, 如果你要的内存小, 这些冗余的信息所占的比例就大.

这段没有必要太纠结. 太深入了.

