# default 和 delete

如果你自己定义了一个 ctor, 那么编译器就不会再给你一个 ctor, 如果你强制加上 =default, 那么就可以重新获得并且使用 default ctor.

首先, 如果你不写 ctor, 不写 assign, copy ctor, 还有 dtor 的话, 系统会给你一个默认的版本, 这些默认的版本什么都没有做, 但是里面会有着对于基类版本的调用. 在自定义的时候, 一定要记住这一点. 继承体系, 还是封装原则, 每个类仅仅是处理自己的成员变量. 对于父类的成员变量, 调用父类的方法进行处理才对.

现在有了 default, delete, 可以将这 big 4 明确的写出来了, 只不过不想自己定义的, = defalut 就可以了, 不想要实现的 = delete 就可以了. 不过, 这两个关键字, 只能作用到这 big 4函数里面.

不过, 更加复杂的却不是上面的两个关键字, 而是 c++ 为了管理内存而做的规定.

什么时候, 需要自己实现, assign, copy ctor 呢, 那就是, 有一些内存要自我管理的时候. 这个时候, 一般自己内部会有一个指针, 指向堆空间. 如果仅仅进行浅拷贝, 原有数据 delete 的话, 堆空间也就没有了, 所以要在 assign 里面还有 copy 里面做深拷贝的处理. 这是常识.

但是, 这两个函数什么时候被调用呢. 拷贝构造函数, 在函数传值, 返回值, 还有明确的调用拷贝构造函数的时候被调用. 其中, 返回值这个现在好多编译器都没有进行拷贝,而是将函数内生成的对象直接当做返回值了, 这是优化处理, 不过理论上应该是拷贝的. 函数传值也是很熟悉了, 所以有着 pass by ref to const 的号召, 为了提高性能. 不过, 还有些时候调用了拷贝我们总是忘记.

下面的代码, A value;B b(value); 这个时候, 会在 b(value) 的时候, 为了传递参数的值, 首先做一个 A 的 copy ctor 操作, 然后, 在 ma(a) 的时候, 在做一次 A 的 copy ctor 操作, 也就是初始化列表里面, 是调用的 copy ctor, 而如果初始化列表中不写, 在构造函数里面写成 this.ma = a 的话, 就会调用 A 的 assign 的函数.

同样的, 拷贝构造函数里面, 系统默认提供的那个版本, 并不是 bit 位的覆盖而已, 而是调用 ma 的 A copy ctor, assign 函数里面, 系统提供的版本, 也不是 bit 位的覆盖, 而是调用了 A 的 assign 函数, 并且在将子类的成员变量的值设置好之后, 还会调用父类的 copy 和 assign 方法, 因为父类的方法里面, 应该会有相应的内存管理的代码. 所以, 如果整个类的体系, 都做好了内存管理的话, 最底层子类做 copy 和 assign 的话, 内存不应该出问题.

在我们自己写代码的时候, 应该时刻清楚, 哪些只是 bit 位的覆盖, 哪些会是调用相应的方法, 并且不要忘记了, 调用父类的方法, 用来确保内存的安全.

并且, 要用 初始化列表的时候, 还是用初始化列表, 从上面我们看到, 在构造方法里面, 调用 = 操作符, 调用的是 assign, 虽然, copy 和 assign 的实现应该完全一样, 但万一有差别呢.


``` cpp

class A {
public:
    A() = default;
    A(const A&backup) {
        cout << "A copy";
    }
    A& operator=(const A&backup) {
        cout << "A assign";
    }
};

class B {
public:
    B(A a):ma(a) {

    }
    A ma;
};
```
