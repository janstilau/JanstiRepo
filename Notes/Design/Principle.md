# 原则

* 单一职责原则

  类的职责单一, 对外只提供一种功能, 所以引起类变化的原因也应该是只有一个

* 开放关闭原则

  类的改动, 是通过增加代码进行的, 而不是修改源代码.

* 里式转化原则

  任何抽象类出现的地方, 都可以用实现类进行替换.

* 依赖倒转原则

  依赖接口编程, 而不是依赖具体的实现类.

* 接口隔离原则

  不应该强迫用户依赖不需要的接口, 也就是接口功能应该单一, 不要把多余的操作放到接口中.

* 合成复用原则

  集成会导致父类的任何变化, 影响到子类, 如果用对象的组合, 就降低了这种依赖. 使用继承, 一定要严格的认定, 子类是一个父类的时候.

* 最少知识原则

  一个对象, 应该尽可能的对于其他对象少的了解, 降低各个对象之间的耦合. 在类的编写的时候, public 的东西只能是需要暴露的东西. 对于其他类来说, 自己的类就是个黑盒.

## 开放关闭原则

对扩展开放, 对修改关闭, 增加功能是增加代码实现的, 而不是修改源代码.

例子, 一个大的 switch, 然后根据 switch 进行不同的操作. 但是这种代码, 需要增加功能的时候, 就要修改全部的源代码, 增加了出错的机会.

改变的方法是, 写一个抽象类, 然后写几个实现类, 这样 switch 的过程, 变成了多态的过程. 不过, 平时写代码的时候, 这样写会造成类的爆炸.

这样写, 在有新的业务功能的时候, 就写一个新的实现类. 而调用的时候, 抽象类的接口不变. 大段的代码不用被修改.

## 最少知识原则

暴露最少的接口给外界. 如果两个类拥有类似的接口, 可以抽取共同父类, 所有的代码依赖父类接口.

从使用者的角度来看, 当使用的类, 暴露太多的接口之后, 其实是很难用的. 作为使用者, 只想通过某个类完成某个功能, 暴露的太多, 反而让类的实现暴露出去了, 让使用者不知道怎么使用这个类. 使用者是不在乎实现细节的, 这应该是一个黑盒.

## 合成复用原则

继承和组合, 优先使用组合.

使用继承, 应该严格一点, 首先, 子类是不是一个父类, 子类的接口特征是不是完全符合父类的, 子类的意义是不是父类的. 一个人有 run 方法, 一个车有 run 方法, 然后人可以继承车, 这不符合逻辑的.

再有, 组合是设计模式中, 能够实现动态切换功能的基础. 多态, 由静态和动态两部分组合, 静态的就是不同类之间的继承关系, 这个是程序运行过程中不能变化的, 能够变化的, 只能是内存中的值. 我们通过切换指针的指向, 让功能切换到不同的线路上, 这就和查字典一样, 字典的早早就编好的, (如果不是动态语言), 我们只能改变页码的那个数字, 去到不同的字典页取得实现二进制代码数据.

## 依赖倒转原则

传统的依赖:
高层-->中层-->底层
依赖的方向 -->
这种问题是, 一层依赖一层, 各层之间仅仅是一个调用的关系. 各层之间, 需要知道具体的实现类的名称, 类方法的名称, 硬编码.

```cpp
void top() {
  A *a = new A();
  middel(a);
}

void middle(A *a) [
  a.businessA();
]

class A{
  void businessA();
}
```

面向抽象:
高层 --> 抽象层 <-- 实现层
依赖的方向 --> 抽象层 <--
高层, 调用中层业务逻辑, 中层, 调用的是接口, 而底层, 实现接口, 接口是联系业务和底层实现的枢纽.
这样写, 在业务层想要不同的功能的时候, 修改 new 的对象的类型, 以及添加一个新的底层实现层就可以了, 而传统的则是, 三个层都要修改, 而且修改需要更改原来的代码. 高层, 底层, 通过抽象接口进行了链接.

```cpp
void top() {
  A *a = new ConcreteA();
  middel(a);
}

void middle(A *a) [
  a.business();
]

class A{
  virtual void business();
}

class ConcreteA: public A{
  void business();
}
```
