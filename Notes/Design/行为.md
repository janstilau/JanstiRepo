# 行为模式

## 模板方法

父类定义一个算法的骨架, 然后将一些步骤延迟到子类中, 模板方法, 使得子类可以不改变算法的结构, 就可以重新定义该算法的某些特定步骤.

封装不变, 扩展可变, 提取公共, 父类控制逻辑, 子类控制具体细节.

## 策略模式

一个类的行为或者算法, 在运行时会改变, 我们将算法封装起来, 让他们可以相互替换.

这是函数不是一等公民的时候无奈的解决办法. 而且, 所有的策略对象的方法原型必须一样.

还是那句话, 要想动态改变一个类的行为, 只能用组合的方法.

## 命令模式

封装请求.

命令模式, 可以让请求发送者和接受者完全解耦, 发送者和接受者之间没有直接的引用关系, 发送请求的对象, 只需要知道如何发送请求, 而不必知道如何完成请求.

为什么要封装请求. 如果不封装请求, 在改变数据的时候, 应该怎么做呢. 在按钮的回调中, 取得数据, 然后调用相应的数据改变的代码, 刷新页面. 这样有什么问题.

* 回调里面, 要清楚怎么操作数据. 在另外的一个需要操作数据的地方, 相同的代码要重复一份. 相应的要修改命令的执行效果时, 要修改多出.
* 没有办法记录操作的顺序. 没有办法撤销, 重做.

命令模式, 本质上, 封装的还是操作. 这个操作, 用对象的方式进行了封装, 因为有对象, 才能进行记录, 才能入队, 出队, 才能在对象里面记录状态.

现在的命令模式, 大部分是用到了 undo command 里面了. 也可以在服务器中, 服务器根据请求, 要做不同的操作. 那么可以根据这些数据, 创建不同的命令对象, 然后从队列中取这些命令对象. 这样比存储字符串然后根据字符串的协议用 switch 处理要清晰的多.

## 观察者模式

建立对象和对象之间的依赖关系, 一个对象发生改变的时候, 会自动通知其他对象, 其他对象作出相应的反应. 观察者模式中, 发生变化的对象, 叫做观察目标, 而被通知的对象, 则为观察者. 一个观察目标可以对应多个观察者.

现在任何和 UI 回调相关的设计, 都用到了观察者模式. 可能实现的方法各不相同, iOS 的 target action, qt 的信号和槽, 都是在一个状态发生改变之后, 通知观察者自身的状态改变, 当然, 实现的具体细节是不一样的.

## 装饰模式

可以动态的给一个类增加功能.