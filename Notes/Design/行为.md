# 行为模式

## 模板方法

父类定义一个算法的骨架, 然后将一些步骤延迟到子类中, 模板方法, 使得子类可以不改变算法的结构, 就可以重新定义该算法的某些特定步骤.

封装不变, 扩展可变, 提取公共, 父类控制逻辑 , 子类控制具体细节.

一般, 父类里面有这些东西, abstractMethodd1, abstractMethod2, 这是子类必须要实现的, templateMethod, 这是父类已经实现的算法步骤, hook, 所谓的hook, 就是父类有实现, 子类可以覆盖实现. 比如, 这可以是一个bool返回值的函数, 默认true, 子类里面可以返回false, 通过这个hook, 可以改变template算法的实现.

其实, 框架, 就是模板模式, 就是不同的框架的运行步骤, 其实那些大公司已经订完了, 所以我们只用实现里面的一些特定方法, 就能改变程序的功能, 因为这些改变的程序, 已经在框架里面安装好了钩子.

实际上, 所有的要求传入函数闭包的函数, 都可以认为是模板方法, 也就是说, 一个方法, 框架已经打好了, 你需要做的, 就是传入这个框架需要的一个函数, 这个函数在框架的运行中, 会起到作用. 例如, foreach, sort, map, 等等等, 并且, 这种把函数当做参数的编程风格, 会愈来愈流行.

在一个好的框架里面, 会有一个对象, 调用不同的对象实现功能, 这些不同的对象按照规定好的方法依次调用, 就可以让程序正常运转, 这样就让每个类只用关心自己的事情, 达到了功能的单一化, 并且, 在调用的过程中, 高层无需知道底层的实现细节, 仅仅是调用就可以了. 底层具体做什么是底层的职责, 高层是根据接口调用代码.


## 命令模式

封装请求.

命令模式, 可以让请求发送者和接受者完全解耦, 发送者和接受者之间没有直接的引用关系, 发送请求的对象, 只需要知道如何发送请求, 而不必知道如何完成请求.

为什么要封装请求. 如果不封装请求, 在改变数据的时候, 应该怎么做呢. 在按钮的回调中, 取得数据, 然后调用相应的数据改变的代码, 刷新页面. 这样有什么问题.

* 回调里面, 要清楚怎么操作数据. 在另外的一个需要操作数据的地方, 相同的代码要重复一份. 相应的要修改命令的执行效果时, 要修改多出.
* 没有办法记录操作的顺序. 没有办法撤销, 重做.

命令模式, 本质上, 封装的还是操作. 这个操作, 用对象的方式进行了封装, 因为有对象, 才能进行记录, 才能入队, 出队, 才能在对象里面记录状态.

现在的命令模式, 大部分是用到了 undo command 里面了. 也可以在服务器中, 服务器根据请求, 要做不同的操作. 那么可以根据这些数据, 创建不同的命令对象, 然后从队列中取这些命令对象. 这样比存储字符串然后根据字符串的协议用 switch 处理要清晰的多.

## 观察者模式

建立对象和对象之间的依赖关系, 一个对象发生改变的时候, 会自动通知其他对象, 其他对象作出相应的反应. 观察者模式中, 发生变化的对象, 叫做观察目标, 而被通知的对象, 则为观察者. 一个观察目标可以对应多个观察者.

## 迭代器模式

用一种方法顺序的访问一个聚合对象的各个对象.

如果没有迭代器, 想要获取一个容器类的各个元素应该怎么做呢, 可能最方便的做法就是, 将容器类内部的处理逻辑暴露出去, 将内部是用array, list, 或者map存储元素的真正的数据结构暴露出去, 然后让调用者对这个数据结构进行操作, 这是一个很危险的行为, 并且, 在遍历的代码里面, 因为是获取不同的数据结构, 所以要用不同的代码遍历这些数据结构, 这个遍历的操作不能同意起来.

迭代器对象, 是一个实现了迭代接口的对象, 所有的容器类, 都会有一个内置的迭代器类, 这个迭代器类实现了迭代接口, 并且保存了一个自己数据结构的指针在迭代器对象里面. 在迭代器的next, hasNext等函数的实现里面, 其实就是对这个指针做操作. 这样的好处在于, 在遍历的代码里面, 拿到容器类内部的迭代器就可以遍历, 不需要知道容器类里面到底是什么数据结构. 更重要的是, 遍历的操作统一了, 只用调用接口就可以了.

迭代器, 不一定有序. 这和不同类的实现方式有关.

## 备忘录模式

在不破坏封装的前提下, 存储关键对象的重要状态, 从而可以在将来把对象还原到存储的状态.


## 桥接模式

* 例子

遥控器, 有两个不同的遥控器功能模板, 一个简单地, 只有频道调节, 音量调节, 一个复杂的, 除了上面两项, 还有回看功能. 遥控器实现上, 有一个遥控器接口, 这是遥控器的实现类统一的接口, 比如设置频道, 设置音量, 有着索尼遥控器, 夏普遥控器.

那么, 如果继承的方式, 这个问题怎么解决. 继承自索尼遥控器, 实现简单模板接口. 在简单模板的实现代码里面, 是调用索尼遥控器已有实现. 对应的, 还有夏普简单遥控器, 索尼复杂遥控器, 夏普复杂遥控器.

这个时候, 如果增加了一个模板, 高级遥控器模板, 增加了设置菜单功能呢, 或者增加了厂商, 例如任天堂遥控器呢.

桥接模式, 让实现和抽象分离. 这里的抽象, 指的是上面的功能模板. 其实我们可以看到, 功能模板里面功能的实现, 是根据遥控器实现里面的功能, 这对于不同厂商的遥控器而言, 完成一个模板的代码是完全一样的. 所以, 增加一个模板, 实际是可以用一个遥控器对象统一完成的. 而这个对象, 可以指向不同的实现类, 从而达到实现层面的变化.

## 中介者模式

就是MVC 里面的 controller, contoller 知道任何的对象, 它负责统一处理所的对象的状态的切换. 这样就把不同对象相互发送消息的网状通信, 变成了各个对象和中介者的通信了.

中介, 使得各个对象不需要显示的相互引用, 但是, 中介者必须要和各个对象有显示的引用. 相当于把网归并到一个节点.