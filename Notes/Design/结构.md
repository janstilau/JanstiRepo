# 结构

## 代理模式

为其他对象提供一种代理, 控制这个对象的访问. 在某些情况下, 一个对象不适合或者不能直接引用另一个对象, 而代理对象可以在客户端和目标对象之间起到中介的作用. 控制 + 中介.

例子:

* 权限控制 (控制)
* 远程服务 (中介)  --> 科学上网, 代理服务器, 缓存服务器.
* 数据库访问

代理, 和代理对象, 要有一套共有的接口, 也就是一个抽象类的子类. 然后在代理类中, 用组合的方式, 控制代理对象.

## 外观模式

* 例子, 看电影的时候, 开dvd, 开音响, 开投影仪, 开幕布, 用到了很多的遥控器

解决的办法就是, 用一个新的遥控器, 只有几个键, 开始, 暂停, 结束, 然后每一个功能运行的时候, 是去调用子系统的功能. 也就是说, 定义了一个新的遥控器, 控制之前复杂的遥控器.

外观模式就是将复杂的子系统, 抽象到同一个接口进行管理, 外界只需要通过此接口和子系统进行交互, 而不必要直接和复杂的子系统进行交互.

外观模式, 其实就是增加一个管理者, 将切割出来的各个对象进行统一的管理. 其实这种方法在编程的时候经常使用, draw 方法里面有着复杂的逻辑, 但是外界仅仅调用 draw 方法就可以, draw 里面是复杂的一层层画数据的过程.

## 适配器

将一个类的接口, 转换成为客户希望的另外一个接口, 使得原来接口不兼容而不能一起工作的那些类一起工作.

## 策略模式

分别封装行为接口, 实现算法族, 超类里面放行为的接口对象, 子类里面放具体的行为对象, 原则就是:

分离变化部分, 封装接口, 基于几口编程各种功能, 这个模式让行为算法的变化独立于算法的使用者.

还是那句话, 要想动态改变一个类的行为, 只能用组合的方法.

* 例子

当一个类的某个行为, 子类的表现分为几种的情况下, 例如, 一个人在公共场合面对突发事件的反应, 有 逃跑, 解决问题, 旁观, 这些行为, 定义在超类里面自然是不合适的, 因为没有一个统一的一个行为是所有人都适用, 但是也不是每个类都不一样. 例如, 警察军人是解决问题, 懦夫逃跑, 其他的都是旁观, 所以每个类实现一次也冗余. 这个时候, 就应该定义一个行为族, 一个接口, 三种表现, 在超类里面有个接口对象, 各个子类中定义具体的接口实现对象.

这个模式, 变化的部分是行为, 这个行为的变化, 是和类的变化独立的. 所以把它抽取出来, 用组合的方式进行了管理.

## 装饰者模式

* 例子, 咖啡 + 牛奶 + 调料 的例子.

如果每个组合都设计新类, 就会有类爆炸的问题

如果超类里面, 包含所有的调味品, 但是有些问题, 新加调料, 就会超类进行重新设计

装饰者模式, 就像打包快递, 一层层包装. 动态的将新功能, 加在对象上.

Component 超类, Type
ConcreteComponent 具体子类 Subtype Decorator 装饰类 Subtype, 里面有一个Component指针
ConcerteDecorator 具体的装饰类 Subtype

在装饰者的实现接口的时候, 是自己的代码加上调用Component指针的调用.

* java 里面的装饰者

io结构.

符合开放关闭原则.


## 状态模式

如果一个对象, 内部有着状态这一个变量, 根据变量的不同, 他的行为也会有着不同, 那么可以抽取一个状态接口, 这个状态接口, 是所有根据状态变化而变化的函数的集合. 然后在这个对象里面, 保存着这样一个接口对象的指针, 根据多态的特性, 将对象的行为, 封装到不同的状态对象里面. 这样, 可以符合开放封闭原则, 如果添加一个新的状态, 增加一个状态类就可以了. 而原来的功能, 没有被修改. 如果不用状态模式, 在这个对象的内部函数里面, 会有很多很多的switch语句, 这样每次有新需求, 都会有着修改整个代码的危险.

在状态的处理方法里面, 可能会有状态切换的问题, 所以, 状态的构造函数里面, 应该有父对象的指针, 方便状态子类里面调用父类的状态切换的函数. 这里其实有点相互包含.


## 原型模式

通过复制现有实例来创建新的实例, 无须知道相应类的信息.

通过原型模式创建对象的方式比new 更加有效, 所以重复创建相似对象的时候可以使用原型.

不过, 要配置一个克隆方法, 并且需要考虑深拷贝.

原型模式是和单例冲突的, 所以单例不要要有clone函数.

Prototype 的意义在于，你拿到一个 Base* ，它指向某个 Derived 对象，你想克隆出 Derived 对象，但代码中不写出 Derived 的具体类型，因为有很多派生类，这种情况下你用构造函数是搞不定的，type-switch 是 bad smells 。另外，这里考虑 virtual 的性能损失是主次不分，构造对象需要分配内存，这开销比一次虚函数调用大多了。Prorobuf Message 就采用了 prototype 模式，你可以参考一下。

## 享元模式

tableview的单元格缓存池就是这种技术.

通过共享的方式, 高效的支持大量细粒度的对象.

减少了运行时的对象实例对象, 节省了创建开销和内存.

视图里面, 需要显示列表的地方, 都可以用缓存池的技术.

