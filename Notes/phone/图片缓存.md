# 图片缓存

现在对于闭包又有了新的理解, 回看之前的图片缓存代码.

* ImageView

ImageView 逻辑是

1. 如果内存有图, 则直接取内存图, 设置图片, 然后执行自己的回调
1. 否则调用 Image 方法, Image 方法的回调会传出一个 Image 对象来, 在 Image 的回调里面, 判断image 的 cacheUrl 和自己的 cacheUrl 是不是相等, 如果是的话, 就证明 ImageView 现在没有后面的 set 任务所覆盖. 然后做一个动画显示得到的图. 然后执行自己的回调

ImageView 的方法都是在主线程做的, 但是, 这只是保证调用 Image 的方法之前的那些是在主线程. 这里一定要清楚, 当我们传递一个闭包给另外一个函数的时候, 我们只能够保证, 调用这个函数是在当前的线程中, 但是这个函数做了什么我们不知道, 这个函数怎么用这个闭包我们也不知道.
当我们深入发掘看这个 Image 的方法的时候, 我们知道它其实是调用 Data 的方法, 然后 Data 的方法里面, 其实是在硬盘没有缓存的情况下做了异步处理的. 那么这个时候, 我们在 ImageView 传递出去的闭包, 其实是包含在 Image 的闭包里面, 在 Data 的网络下图方法的回调里面被调用的. 这个时候的回调是在主线程里面, 是在下图的回调里面明确的指定了, 回调要在主线程里面调用. 这和我们在调用 ImageView 的方法的时候, 规定要在主线程里面已经是两码事了, 我们在 ImageView 里面的这个规定, 只是为了保证, 在内存中有图的情况下, 将这个图赋值到 ImageView 的过程中, 是在主线程环境而已.

* Image

Image 这里直接调用了 Data 的 Url 相关的代码. 然后在 Data 的 Url 方法会返回一个 NSData 来, 根据这个 Data, 判断是不是 gif 图, gif 图需要特殊处理. 然后生成一个 image, 如果这个 image 尺寸不太大, 就放到内存缓存中. 然后, 调用自己的 CompleteBlock, 将这个新生成的 image 传出去. 这个 CompleteBlock, 是在 ImageView 那里设置过来的.

* Data

1. 如果本地磁盘有缓存, 那么就取出缓存, 然后调用回调
1. 如果没有, 那么就将 Url, Process Block, Complete Block 传递到 ImageCacheManager 中, 在这里会有下载图片.

整个流程其实有几个属性进行控制, exist 属性, 整个属性控制着, 最后 ImageView 的出现有没有动画效果.
cache_url 属性, 这个就是判断, ImageView 的当前任务有没有改变了, ImageView 可能被多次 setImage, 假设, 现在一张图都没有, 所有的图都要下载. 那么在第一张图下完之后调用回调的时候, ImageView 的当前任务可能是第三张图了. 这在 tableview 的时候特别容易出现. 所以, 这里要做一个判断.
identity 属性, 是判断当前的下载任务是在哪一个页面上. 当用户切换页面的时候, 应该将下图的优先级移到当前的页面上来. 而且, 在用户移动 tableView 的时候, 应该将正在观看位置的图移到下载的前列. 这些都是根据 identify 进行控制的.

* ImageCacheManager
