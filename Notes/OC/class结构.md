# class结构

isa 指针
superclass
cache
bits {
属性信息
对象方法
协议信息
成员变量信息
}



元类对象和类对象是完全一样的结构, 只不过, 元类对象的对象方法, 是类方法. 而元类对象里面, 没有属性, 协议, 成员变量的信息.

当程序运行的时候, runtime 加载过程发现有一个类, 会自动生成一个类对象和对应的元类对象, 然后注册到 runtime 之中. 所以, 元类对象和类对象的生成, 一般我们不会直接进行操作.

## 缓存 cahce_t

当对象接受到消息的时候, 会首先到自己的类对象的 cache_t 中查找, 相应消息的IMP. 如果有, 则直接调用
没有的话, 会在 rwt 的 methods 中查找对应的实现, 找到的话, 会将对应的 IMP 放到 cache_t 中, 然后调用.
没有的话, 会通过 superclass 找到父类的类对象, 首先查找父类的 cache_t, 找到的话, 会将对应的 IMP 在子类的 cache_t 也做一份缓存, 然后调用实现.
没有的话, 会在父类的 rwt 的 methods 中, 查找对应的 IMP. 找到的话, 还是在子类的 cache_t 做一份缓存. 然后调用. 
没有的话, 继续通过父类的 superclass 重复这个过程.
原则就是, 无论是在哪一个层级找到的实现, 都要在相应类的类对象中, 做一次缓存操作. 方便之后的方法调用.

缓存是一个散列表, 当散列表需要进行扩展的时候, 原来缓存的数据会全部丢失, 这个时候, 在调用原来已经缓存好的方法的时候, 还会重新走一次寻路的过程.