#ifndef JAVATHREADPOOL_H
#define JAVATHREADPOOL_H

/*

https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html
美团技术团队, 对于线程池技术的阐述. Java 语言.


池化的主要作用在于:
1. 统一管理, 使得资源在可控的范围内.
2. 重复利用, 可以快速的相应对于资源的申请, 也避免了频繁的构造析构造成的损失.
内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。
线程池, 重复利用线程. 减少对于线程的开辟. 并且让线程的开辟数量, 在 Pool 的管理范围内.


将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。
// 从这里来看, 类似于 std::async, Qt::run, Gcd 等快速提交任务的接口.
// 这里的关键点就是, 应该提供一个方便的接口, 来提交任务. 到底怎么执行, 如何执行这不是使用者考虑的问题.

ThreadPoolExecutor 的设计意图, 和 QThreadPool 基本一直.
1. 任务缓存.
2. 线程管理.
3. 调度管理.
线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

// 这里是 Java 的 ThreadPoolExecutor 提交任务后的处理策略: 增加了拒绝相关的设计.
首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

// 这里, 是吧 wait 的操作, 封装到了队列的读取里面.
任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。
阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。

// 这里的设计思路, 比较统一.
任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。


// Qt 也有相关的一个线程子类.
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;//Worker持有的线程
    Runnable firstTask;//初始化的任务，可以为null
}
在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：
1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。

后面的内容, 都是和业务相关的阐述. 不过, 可以看出不同的平台, 对于线程池的设计是大同小异的.

*/


#endif // JAVATHREADPOOL_H
