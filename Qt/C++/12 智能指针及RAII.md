# 智能指针及RAII

#### 问题

C++中最令人头疼的问题是强迫程序员对申请的资源（文件，内存等）进行管理，一不小心就会出现泄露（忘记对申请的资源进行释放）的问题。



```C++
// C++
auto ptr = new std::vector<int>();
```



```java

//使用了垃圾回收技术,不在需要人为管理，相关的虚拟机会自动释放不需要使用的资源。
// Java
ArrayList<int> list = new ArrayList<int>();
```



```python
# Python
lst = list()
```



#### C++的解决办法：RAII

Resource acquisition is initialization.

在传统 C++ 里我们只好使用 `new` 和 `delete` 去『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。

#### 解决思路：

- 利用C++中一个对象出了其作用域会被自动析构，因此我们只需要在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，这样，就减轻了程序员在编码过程中，考虑资源释放的问题，这就是**RAII**。

**RAII**，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。

- 有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。
- RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。

具体而言，C11的stl中为大家带来了3种智能指针，正确合理的使用可以有效的帮助大家管理资源，当然，在C++的使用智能指针没有像Java,python这种具备垃圾回收机制的语言那么舒适，毕竟，程序员还需要做一些额外的事情，但是，这远比传统的C或者C++更加优雅。

3种智能指针分别是：

- `std::shared_ptr` 强指针
- `std::unique_ptr`
- `std::weak_ptr ` 弱指针

在早期有一个auto_ptr，这四种指针在使用上有区别：

-  auto_ptr有缺陷是过时的产物。

-  unique_ptr对auto_ptr的问题进行了修正。

-  shared_ptr使用了引用计数，但是会出现循环引用的问题需要配合后面的weak_ptr一起使用。