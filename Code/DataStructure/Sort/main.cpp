//
//  main.cpp
//  Sort
//
//  Created by JustinLau on 2019/3/9.
//  Copyright © 2019 JustinLau. All rights reserved.
//

#include <iostream>

/*
 排序:
 排序有两种操作
 1. 比较.
 1. 移动. 不同的排序算法, 移动的规模是不一样的, 所以考虑排序的时候, 一定要考虑移动的次数
 
 其实上面的就是计算机能做的最主要的操作了,
 
 排序的空间复杂度
 in-place 排序, 值得是在原有空间上进行排序, 不引入新的数组或者链表就行存储. 例如, 冒泡, 选择, 都是inplace 排序
 空间复杂度临时存储空间是可以的, 但是如果要根据 n 进行缓存的存储, 那么就应该算到空间复杂度里面了.
 
 稳定性.
 稳定的排序算法是, 在排序过后, 原有的相同的两个值, 前后顺序保持不变.
 为什么要追求稳定性呢. 这是因为, 我们写排序的 demo 都很简单, int, 两个值前后变化没有什么影响. 但是, 如果是一个复杂的模型, 比如排队, 我们先用年龄排序, 然后用每个人的积分排序. 年龄排序是我们的第二标准, 在年龄相同的时候, 通过积分排序. 在积分排序的过程中, 要保持原有的顺序不变的. 如果年龄相同的两个人, 根据积分排序之后的顺序发生了改变, 这很有可能导致年龄排序的结果被破坏了. 所以, 一定要准求排序的稳定性.
 那么, 如果是一个稳定的排序算法, 我们想要根据好几个标准进行排序的话, 先按照最低标准进行排序, 最后按照最高标准进行排序. 最后进行的排序, 会有着最大的优先级, 比如, 年龄, 分数, 分数最后排, 一定是分数高的在前面, 但是这个排序规则不会打破年龄排序的前后关系, 这样就能保持, 分数相同的时候, 也是有着年龄的先后顺序的.
 
 排序算法可以设置 flag, 如果在一次的迭代过程中, 没有发生过交换, 那么这个数组就是有序的了, 那么就可以提前退出了. 这是优化排序算法的一个很简单又很有效的做法.
 
 有序元素对:a[i] <= a[j], 如果 i < j。
 逆序元素对:a[i] > a[j], 如果 i < j。
 逆序度 = 满有序度 - 有序度。我们排序的过程就是一 种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了.
 就和查找一样, 查找的过程, 如果一次操作能够大量的筛选调不符合的 item 的话, 那么这个查找的效率就高, 而排序的过程, 如果一次操作能够大量的消除逆序对的话, 那么这个排序的效率就高.
 对于 n2 的排序算法, 每一次比较, 移动, 只能减少一个逆序对, 而其他的排序算法, 归并在合并两个字序列的过程中, 快排在交换两个位置元素的过程中, 都一次性消除了大量的逆序对, 所以他们的效率就高.
 
 满有序度 = n(n-1)/2
 
 冒泡排序的思路是, 按照顺序比较 n 和 n+1 位置的元素, 如果需要互换的话, 就进行互换, 这样, 能够保证一次循环之后, 最大或者最下的元素, 一定会在数组的最后方.
 在冒泡排序中, 一次交换, 有序度就+1, 所以, 冒泡排序中, 交换的次数就是逆序度的sum 值.
 
 
 插入排序:
 我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元 素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到 合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元 素为空，算法结束。
 冒泡排序的时间复杂度为 n2, 主要的操作, 其实是浪费在了移动数组的过程中, 在这个过程中, 移动一次, 就会减除一个逆序对. 所以, 插入排序也是比较慢的排序.
 
 选择排序, 是一种不稳定的算法.
 选择排序, 在移动元素的时候, 一次可以消除大量的逆序对, 但是在寻找最大最小值的过程中, 需要大量的比较操作, 所以, 也是 n2 的时间复杂度.
 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第 一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排 序和插入排序，选择排序就稍微逊色了。
 
 我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固 定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据 的逆序度。
 但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。这也是为什么插入排序的性能要好过冒泡的地方.
 
 冒泡排序中数据的交换操作:
 (a[j] > a[j+1]) { // 交换 int tmp = a[j];
 a[j] = a[j+1];
 a[j+1] = tmp;
 10 11 12 13 14
 插入排序中数据的移动操作:
 a[j+1] = a[j]; // 数据移动
 
 所以, 既然数据交换的次数一样, 那么交换步骤少的算法效率更高.
 */

// 每次循环, 找到应该调换的角标. 大部分都是做判断操作, 只有n 次是做值得替换.
void selectSort(int *datas, int length) {
    for (int i = 0; i < length; ++i) {
        int minIndex = i;
        for (int j = i+1; j < length; ++j) {
            if (datas[j] < datas[minIndex]) {
                minIndex = j;
            }
        }
        int temp = datas[i];
        datas[i] = datas[minIndex];
        datas[minIndex] = temp;
    }
}

// 每次循环, 从后向前依次和自己相邻的比较, 然后将小的数据不断地向前移动. 这个移动的过程, 要比选择排序耗费性能.
// 这里需要优化, 在某一次循环之中, 如果没有移动操作, 证明现在已经处于有序的状态了, 整个排序的过程, 也就可以提前退出了.
void bubbleSort(int *datas, int length) {
    for (int i = 0; i < length; ++i) {
        for (int j = length-1; j > i; --j) {
            if(datas[j] < datas[j-1]) {
                int temp = datas[j];
                datas[j] = datas[j-1];
                datas[j-1] = temp;
            }
        }
    }
}

void insertSort(int *datas, int length) {
    if (length <= 1) { return; }
    for (int i = 1; i < length; ++i) {
        int value = datas[i];
        int j = i-1;
        for (; j >= 0; --j) {
            if (value < datas[j]) {
                datas[j+1] = datas[j];
            } else {
                break;
            }
        }
        datas[j] = value;
    }
}

int main(int argc, const char * argv[]) {
    int datas[10] = {1, 123, 123, 33, 221, 121312, 12323, 123553,56346, 346};
    insertSort(datas, 10);
    for (int i = 0; i < 10; ++i) {
        std::cout << datas[i] << " ";
    }
    
    
    return 0;
}
