//
//  main.cpp
//  Sort
//
//  Created by JustinLau on 2019/3/9.
//  Copyright © 2019 JustinLau. All rights reserved.
//

#include <iostream>

/*
 排序:
 排序有两种操作
 1. 比较
 1. 移动. 不同的排序算法, 移动的规模是不一样的, 所以考虑排序的时候, 一定要考虑移动的次数
 
 排序的空间复杂度
 in-place 排序, 值得是在原有空间上进行排序, 不引入新的数组或者链表就行存储. 例如, 冒泡, 选择, 都是inplace 排序
 
 稳定性.
 稳定的排序算法是, 在排序过后, 原有的相同的两个值, 前后顺序保持不变.
 为什么要追求稳定性呢. 这是因为, 我们写排序的 demo 都很简单, int, 两个值前后变化没有什么影响. 但是, 如果是一个复杂的模型, 比如排队, 我们先用年龄排序, 然后用每个人的积分排序. 年龄排序是我们的第一标准, 在年龄相同的时候, 通过积分排序. 在积分排序的过程中, 要保持原有的顺序不变的. 如果积分相同的两个人, 排序之后的顺序发生了改变, 这很有可能导致年龄排序的结果被破坏了. 所以, 一定要准求排序的稳定性.
 
 排序算法可以设置 flag, 如果在一次的迭代过程中, 没有发生过交换, 那么这个数组就是有序的了, 那么就可以提前退出了. 这是优化排序算法的一个很简单又很有效的做法.
 
 有序元素对:a[i] <= a[j], 如果 i < j。
 逆序元素对:a[i] > a[j], 如果 i < j。
 逆序度 = 满有序度 - 有序度。我们排序的过程就是一 种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了
 
 满有序度 = n(n-1)/2
 
 在冒泡排序中, 一次交换, 有序度就+1, 所以, 冒泡排序中, 交换的次数就是逆序度的sum 值.
 
 
 插入排序:
 我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元 素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到 合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元 素为空，算法结束。
 
 选择排序, 是一种不稳定的算法.
 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第 一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排 序和插入排序，选择排序就稍微逊色了。
 
 我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固 定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据 的逆序度。
 但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。
 
 冒泡排序中数据的交换操作:
 (a[j] > a[j+1]) { // 交换 int tmp = a[j];
 a[j] = a[j+1];
 a[j+1] = tmp;
 10 11 12 13 14
 插入排序中数据的移动操作:
 a[j+1] = a[j]; // 数据移动
 
 所以, 既然数据交换的次数一样, 那么交换步骤少的算法效率更高.
 */

// 每次循环, 找到应该调换的角标. 大部分都是做判断操作, 只有n 次是做值得替换.
void selectSort(int *datas, int length) {
    for (int i = 0; i < length; ++i) {
        int minIndex = i;
        for (int j = i+1; j < length; ++j) {
            if (datas[j] < datas[minIndex]) {
                minIndex = j;
            }
        }
        int temp = datas[i];
        datas[i] = datas[minIndex];
        datas[minIndex] = temp;
    }
}

// 每次循环, 从后向前依次和自己相邻的比较, 然后将小的数据不断地向前移动. 这个移动的过程, 要比选择排序耗费性能.
void bubbleSort(int *datas, int length) {
    for (int i = 0; i < length; ++i) {
        for (int j = length-1; j > i; --j) {
            if(datas[j] < datas[j-1]) {
                int temp = datas[j];
                datas[j] = datas[j-1];
                datas[j-1] = temp;
            }
        }
    }
}

void insertSort(int *datas, int length) {
    if (length <= 1) { return; }
    for (int i = 1; i < length; ++i) {
        int value = datas[i];
        int j = i-1;
        for (; j >= 0; --j) {
            if (value < datas[j]) {
                datas[j+1] = datas[j];
            } else {
                break;
            }
        }
        datas[j] = value;
    }
}

int main(int argc, const char * argv[]) {
    int datas[10] = {1, 123, 123, 33, 221, 121312, 12323, 123553,56346, 346};
    insertSort(datas, 10);
    for (int i = 0; i < 10; ++i) {
        std::cout << datas[i] << " ";
    }
    
    
    return 0;
}
