//
//  main.cpp
//  Recusive
//
//  Created by JustinLau on 2019/3/9.
//  Copyright © 2019 JustinLau. All rights reserved.
//

#include <iostream>

/*
 递推.
 首先是定义, 这里有一个例子可以举出来. 想要知道自己在第几排, 问前面一排, 前面想要知道自己在第几排, 问自己的前面一排... 最前面一排的人, 知道自己的排数为1, 然后回传, 每个排数的人将结果+1, 最终, 我们能够从前面一排知道前面一排是多少, +1就是我们自己的.
 递归, 递的过程, 就是调用范围更小的子问题的过程, 回的过程, 就是拿到子问题的解决答案之后, 进行操作的过程. 递归, 递归, 从名字上就说明了这个编程技巧的含义.
 有的时候, 就算在调用了子范围的函数之后没有后续操作, 这其实也是递归的体现. 只不过在归的部分, 没有做操作而已.
 三个条件.
 
 1 一个大问题, 可以转变成为子问题.
 2 子问题的解答思路, 和大问题的解答思路一致
 3 存在子问题的边界条件, 不会将问题再次分解, 然后开始回溯.
 
 递归的编程主要就两部
 1. 找到递归公式, 就是大问题怎么通过子问题的结果
 2. 找到边界条件
 
 然后就是用代码实现递归公式和遇到边界回溯的过程了.
 
 理解递归的时候, 千万不要尝试一步步深究里面的调用层次, 这样很容易将自己绕晕. 找到递归公式, 然后假设, 子问题已经解决了, 我们已经拿到了子问题的结果了, 然后通过子问题的结果, 构建解决当前问题的步骤. 这才是最有效理解递归的关键所在.
 
 递归的问题在于, 可能会有栈溢出, 原因是, 在函数调用的时候, 子函数不出栈, 调用函数是不会出栈的. 这样, 如果递归规模很大, 调用层次过深, 那么有可能系统的栈空间会使用尽.
 第二就是重复计算的问题, 这个问题可以用缓存解决. 例如散列表缓存.
 
 
 */








int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n";
    return 0;
}
